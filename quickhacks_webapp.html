<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QuickHacks - PvP RAM Extraction</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.10.0/dist/web3.min.js"></script>
    <script src="./js/pfp-generator.js"></script>
    <script src="./js/game-map.js"></script>
    <link rel="stylesheet" href="./css/styles.css">
</head>
<body>
    <div class="header">
        <div class="header-item">
            <span class="header-label">live players</span>
            <span class="header-value ram-value" id="livePlayerCount">Loading...</span>
        </div>
        <div class="header-item">
            <span class="header-label">live balance</span>
            <span class="header-value ram-value" id="liveBalance">Loading...</span>
        </div>
        <div class="header-item">
            <span class="header-label">game status</span>
            <span class="header-value ram-value">active</span>
        </div>
        <div class="header-item">
            <span class="header-label">game state</span>
            <span class="header-value ram-value">normal</span>
        </div>
        <div class="header-item">
            <span class="header-label">boss</span>
            <span class="header-value boss-balance">Loading...</span>
        </div>
        <div class="header-item">
            <span class="header-label">current block</span>
            <span class="header-value" id="currentBlock">loading...</span>
        </div>
        <div class="header-item">
            <span class="header-label">gas</span>
            <span class="header-value" id="gasPrice">loading...</span>
        </div>
    </div>

    <div class="container">
        <div class="left-section">
            <div class="game-map-section">
                <div class="panel-header" style="position: relative;">
                    GAME MAP
                    <button class="pfp-btn" onclick="refreshGameMap()" style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%);">refresh</button>
                </div>
                <div class="section-loading" id="mapLoading">
                    <div class="loading-text">loading network map...</div>
                    <div class="loading-bar-container">
                        <div class="loading-bar-section" id="mapLoadingBar"></div>
                    </div>
                </div>
                <div class="section-content" id="mapSection">
                    <div id="gameMapContainer"></div>
                </div>
            </div>
            
            <div class="data-panels">
                <div class="left-panel">
                    <div class="panel-header">ACTIVE PLAYERS</div>
                    <div class="section-loading" id="playersLoading">
                        <div class="loading-text">loading players...</div>
                        <div class="loading-bar-container">
                            <div class="loading-bar-section" id="playersLoadingBar"></div>
                        </div>
                    </div>
                    <div class="player-list section-content" id="playerList">
                        <!-- Players will be populated by JavaScript -->
                    </div>
                </div>

                <div class="middle-panel">
                    <div class="activity-feed">
                        <div class="panel-header">ACTIVITY FEED</div>
                        <div class="section-loading" id="activityLoading">
                            <div class="loading-text">loading activity...</div>
                            <div class="loading-bar-container">
                                <div class="loading-bar-section" id="activityLoadingBar"></div>
                            </div>
                        </div>
                        <div class="section-content" id="activityFeed">
                            <!-- Dynamic activity will populate here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="third-panel">
            <div class="blob-animation">
                <div class="panel-header-with-button">
                    <span>PLAYER PFP</span>
                    <div class="pfp-controls">
                        <span id="seedDisplay" class="seed-display">no player connected</span>
                        <button class="pfp-btn" onclick="regeneratePFP()">regen</button>
                        <button class="pfp-btn" onclick="rotatePFP()">rotate</button>
                        <button class="pfp-btn" onclick="setPFP()">set</button>
                    </div>
                </div>
                <div class="section-loading" id="pfpLoading">
                    <div class="loading-text">generating pfp...</div>
                    <div class="loading-bar-container">
                        <div class="loading-bar-section" id="pfpLoadingBar"></div>
                    </div>
                </div>
                <div class="section-content" id="pfpSection">
                    <div class="blob-content">
                        <div id="pfpContainer"></div>
                    </div>
                </div>
            </div>

            <div class="profile-section">
                <div class="panel-header-with-button" id="profileHeader">
                    <span id="profileTitle">PLAYER</span>
                    <button class="disconnect-btn" id="connectDisconnectBtn" onclick="togglePlayerConnection()">x</button>
                </div>
                <div class="profile-disconnected" id="profileDisconnected">
                    <span>no player connected</span>
                </div>
                <div class="section-loading" id="profileLoading">
                    <div class="loading-text">loading profile...</div>
                    <div class="loading-bar-container">
                        <div class="loading-bar-section" id="profileLoadingBar"></div>
                    </div>
                </div>
                <div class="section-content" id="profileSection">
                    <div class="profile-content">
                
                <div class="detail-section">
                    <div class="transaction-controls">
                        <button class="transaction-btn" onclick="executeDeposit()">deposit</button>
                        <input type="text" class="transaction-input" id="depositAmount" placeholder="0.00" />
                        <span class="transaction-label">ETH</span>
                        <button class="transaction-btn" onclick="executeWithdraw()">withdraw</button>
                        <input type="text" class="transaction-input ram-input" id="withdrawAmount" placeholder="0" />
                        <span class="transaction-label">RAM</span>
                    </div>
                    <div id="transactionStatus" style="display: none; margin-top: 10px; font-size: 9px; color: #50fa7b;"></div>
                    <div class="detail-item">balance         <span class="ram-value">-- RAM</span></div>
                    <div class="detail-item">ETH value       -- eth</div>
                </div>

                <div class="detail-section">
                    <div class="detail-item">⬇ deposits        -- ETH</div>
                    <div class="detail-item">⬆ withdrawals     <span class="ram-value">-- RAM</span></div>
                    <div class="detail-item">withdrawal cooldown --</div>
                </div>

                <div class="detail-section">
                    <div class="detail-item">quickhacks      [--]</div>
                    <div class="detail-item">⮕ damage dealt    <span class="ram-value">-- RAM</span> [+-- attack]</div>
                    <div class="detail-item">⬅ damage taken    <span class="ram-value">-- RAM</span> [+-- defence]</div>
                </div>

                <div class="detail-section">
                    <div class="detail-title">active effects [--/9 slots]</div>
                    <div class="effect-item">No active effects</div>
                </div>

                <div class="detail-section">
                    <div class="detail-title">activity</div>
                    <div class="activity-item">No activity</div>
                </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="right-panel">
            <div class="attack-simulator">
                <div class="panel-header">ATTACK SIMULATOR</div>
                <div class="section-loading" id="simulatorLoading">
                    <div class="loading-text">loading simulator...</div>
                    <div class="loading-bar-container">
                        <div class="loading-bar-section" id="simulatorLoadingBar"></div>
                    </div>
                </div>
                <div class="simulator-content section-content" id="simulatorSection">
                <div class="detail-section">
                <div class="detail-item">target <input type="text" class="target-input" id="targetAddressInput" value="" placeholder="Enter target address"></div>
                <div class="detail-item" style="margin-top: 8px;">balance         <span class="target-balance" id="targetBalance"></span></div>
                <div class="detail-item">defence         <span id="targetDefense"></span></div>
                <div class="detail-item">attack          <span id="targetAttack"></span></div>
                </div>
                
                <div class="detail-section">
                <div class="detail-title" id="effectsTitle">effects</div>
                <div id="effectsList">
                </div>
                </div>

                <div class="detail-section">
                <div class="detail-title">quickhack</div>
                <div class="quickhack-type-buttons">
                    <button class="type-btn attack selected" onclick="selectQuickhackType('attack')">attack</button>
                    <button class="type-btn self-cast" onclick="selectQuickhackType('self-cast')">self-cast</button>
                </div>
                
                <div class="quickhack-options attack-options show" id="attackOptions">
                    <button class="quickhack-btn selected" onclick="selectQuickhack('short circuit')">short circuit</button>
                    <button class="quickhack-btn" onclick="selectQuickhack('overheat')">overheat</button>
                    <button class="quickhack-btn" onclick="selectQuickhack('lag')">lag</button>
                    <button class="quickhack-btn" onclick="selectQuickhack('troll')">troll</button>
                </div>
                
                <div class="quickhack-options self-cast-options" id="selfCastOptions">
                    <button class="quickhack-btn" onclick="selectQuickhack('berserk')">berserk</button>
                    <button class="quickhack-btn" onclick="selectQuickhack('oilbath')">oilbath</button>
                    <button class="quickhack-btn" onclick="selectQuickhack('on/off')">on/off</button>
                    <button class="quickhack-btn" onclick="selectQuickhack('downstream')">downstream</button>
                    <button class="quickhack-btn" onclick="selectQuickhack('icewall')">icewall</button>
                </div>
                </div>
                
                <div class="detail-section">
                <div class="detail-title">estimated results</div>
                <div class="detail-item">damage          <span class="ram-value" id="estimatedDamage">[connect]</span></div>
                <div class="detail-item">cost            <span class="ram-value" id="estimatedCost">[connect]</span></div>
                <div class="detail-item" id="slotsUsedItem">effect slots used by quickhack [1]</div>
                
                <div class="button-group">
                    <button class="refresh-btn" onclick="refreshTargetData()">refresh target</button>
                    <button class="execute-btn" onclick="executeAttack()">execute quickhack</button>
                </div>
                
                <div class="loading-container" id="loadingContainer">
                    <div class="loading-bar" id="loadingBar"></div>
                    <span>in progress</span>
                    <span class="tx-link" onclick="openTxLink()">TX link</span>
                </div>
                </div>

                <div class="result-section" id="resultSection">
                    <div class="detail-section">
                    <div class="detail-item">no transaction yet</div>
                    <div class="detail-item">tx hash         none</div>
                    <div class="detail-item">status          pending</div>
                    
                    <div class="detail-item">balances        waiting for execution</div>
                    <div class="detail-item">                </div>
                    </div>
                </div>
                </div>
            </div>

            <div class="rules-section">
                <div class="panel-header">GAME RULES</div>
                <div class="rules-content">
                    <div class="detail-section">
                        <div class="detail-title">attack quickhacks</div>
                        <div class="detail-item">short circuit: 3% damage, +20% costs (15 min), 1 slot</div>
                        <div class="detail-item">overheat: 2.5% damage, -20% defense (15 min), 1 slot</div>
                        <div class="detail-item">lag: 0.3% damage, instant, 0 slots</div>
                        <div class="detail-item">troll: 1% × defense bonus, instant, 0 slots</div>
                    </div>

                    <div class="detail-section">
                        <div class="detail-title">self-cast quickhacks</div>
                        <div class="detail-item">berserk: +100% damage, overheat immunity (20 min), 2 slots</div>
                        <div class="detail-item">oilbath: -30% costs, -20% defense (30 min), 2 slots</div>
                        <div class="detail-item">on/off: blocks incoming/outgoing quickhacks, resets slots (10 min), 2 slots</div>
                        <div class="detail-item">downstream: +50% def, +25% atk/cost (20 min), 3 slots</div>
                        <div class="detail-item">icewall: +100% defense, lag immunity (20 min), 2 slots</div>
                    </div>

                    <div class="detail-section">
                        <div class="detail-title">balance requirements</div>
                        <div class="detail-item">victim balance needs to be min. 10% of attacker</div>
                        <div class="detail-item">example: 1000 RAM can only fight 100-10,000 RAM</div>
                        <div class="detail-item">prevents dust attacks and whale griefing</div>
                    </div>

                    <div class="detail-section">
                        <div class="detail-title">game modes</div>
                        <div class="detail-item">normal: standard gameplay</div>
                        <div class="detail-item">underload: 30% reduction in damage and costs</div>
                        <div class="detail-item">full moon: 50% increase in damage and costs</div>
                        <div class="detail-item">outage: all attacks disabled, withdrawals only</div>
                    </div>

                    <div class="detail-section">
                        <div class="detail-title">special player states</div>
                        <div class="detail-item">faraday: complete attack immunity</div>
                        <div class="detail-item">boss: immune to effects, direct damage only</div>
                        <div class="detail-item">cheating death: +30% attack/defense bonuses</div>
                        <div class="detail-item">ban: cannot execute attacks</div>
                    </div>

                    <div class="detail-section">
                        <div class="detail-title">progression & economics</div>
                        <div class="detail-item">attack bonus: +1 point per 10k damage dealt</div>
                        <div class="detail-item">defense bonus: +1 point per 5k damage taken</div>
                        <div class="detail-item">rising costs: attack costs increase with progression</div>
                        <div class="detail-item">taxes: 0.5% deposit/withdraw, 1% attack rewards</div>
                        <div class="detail-item">exchange rate: 10,000,000 RAM per ETH</div>
                        <div class="detail-item">withdrawal cooldown: 30 minutes after deposit</div>
                    </div>

                    <div class="detail-section">
                        <div class="detail-title">system limits</div>
                        <div class="detail-item">effect slots: max 9 active per player</div>
                        <div class="detail-item">rate limit: 1 quickhack per block per player</div>
                    </div>

                    <div class="detail-section">
                        <div class="detail-title">boss treasury</div>
                        <div class="detail-item">0x05351d48D04E16b05e388394e6AbB25054D0Ad5a</div>
                    </div>

                    <div class="detail-section">
                        <div class="detail-title">contracts</div>
                        <div class="detail-item">QuickHacksGame: <a href="https://sepolia.basescan.org/address/0x7886E51360A71FCd9e29ef0c41b2a85152284663" target="_blank" style="color: #ceccde; text-decoration: underline;">0x7886...4663</a></div>
                        <div class="detail-item">PlayerManager: <a href="https://sepolia.basescan.org/address/0xD5cFD72426ffE8da3b0E5D184baa3F850510e183" target="_blank" style="color: #ceccde; text-decoration: underline;">0xD5cF...e183</a></div>
                        <div class="detail-item">QuickhackSystem: <a href="https://sepolia.basescan.org/address/0x57d67cB66A76c7Af054F7e99b189EF2E64579ECc" target="_blank" style="color: #ceccde; text-decoration: underline;">0x57d6...9ECc</a></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Player data - initialized empty, populated from subgraph
        let players = [];

        // Special address replacement function
        function getDisplayAddress(address) {
            const bossAddress = '0x05351d48d04e16b05e388394e6abb25054d0ad5a';
            const teamAddress = '0xd63a12d5dd3bccc018735eaebb70a51ed351b56e';
            
            if (address.toLowerCase() === bossAddress.toLowerCase()) {
                return '0xboss';
            } else if (address.toLowerCase() === teamAddress.toLowerCase()) {
                return '0xteam';
            } else {
                return address;
            }
        }
        
        // Responsive address shortening based on viewport width
        function getResponsiveAddress(address) {
            const specialAddress = getDisplayAddress(address);
            
            // If it's a special address (boss/team), return as-is
            if (specialAddress !== address) {
                return specialAddress;
            }
            
            // Check viewport width and shorten if narrow
            const viewportWidth = window.innerWidth;
            
            if (viewportWidth < 1550) {
                // Narrow: show shortened format like activity feed
                return address.slice(0, 6) + '...' + address.slice(-4);
            } else {
                // Wide enough: show full address
                return address;
            }
        }

        // GraphQL query for active players with pagination
        const PLAYERS_QUERY = `
            query GetActivePlayers($first: Int!, $skip: Int!) {
                players(where: {currentBalance_gt: "0"}, orderBy: currentBalance, orderDirection: desc, first: $first, skip: $skip) {
                    id
                    currentBalance
                    totalDeposited
                    totalWithdrawn
                    damageDealt
                    damageTaken
                    attackBonus
                    defenseBonus
                    activeEffects(where: {isActive: true}) {
                        quickhackType
                        effectType
                        magnitude
                        endBlock
                    }
                    activities(first: 10, orderBy: blockTimestamp, orderDirection: desc) {
                        type
                        target { id }
                        quickhackType
                        amount
                        blockTimestamp
                    }
                }
            }
        `;

        // Pagination state for players
        let playersLoaded = 0;
        let hasMorePlayers = true;
        const PLAYERS_PER_PAGE = 50;
        
        // Fetch active players from subgraph with pagination
        async function fetchActivePlayers(first = PLAYERS_PER_PAGE, skip = 0) {
            try {
                const response = await fetch(SUBGRAPH_URL, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    mode: 'cors',
                    body: JSON.stringify({ 
                        query: PLAYERS_QUERY,
                        variables: { first, skip }
                    })
                });
                
                const data = await response.json();
                if (data.errors) {
                    console.error('GraphQL errors:', data.errors);
                    return [];
                }
                
                const newPlayers = data.data.players || [];
                
                // Update pagination state
                if (newPlayers.length < first) {
                    hasMorePlayers = false;
                }
                
                return newPlayers;
            } catch (error) {
                console.error('Failed to fetch players:', error);
                return [];
            }
        }

        // Convert blockchain player data to display format
        async function formatPlayer(player) {
            // Format effects with quickhack names and end blocks
            const quickhackNames = {
                1: 'short circuit', 2: 'overheat', 3: 'lag', 4: 'troll',
                5: 'berserk', 6: 'oilbath', 7: 'on/off', 8: 'downstream', 9: 'icewall'
            };

            // Filter out expired effects and group by quickhack type
            const web3 = new Web3(window.ethereum);
            const currentBlockNumber = await web3.eth.getBlockNumber();
            const activeEffects = player.activeEffects.filter(effect => parseInt(effect.endBlock) > currentBlockNumber);

            const groupedEffects = {};
            activeEffects.forEach(effect => {
                const quickhackType = effect.quickhackType;
                const endBlock = parseInt(effect.endBlock);
                
                if (!groupedEffects[quickhackType]) {
                    groupedEffects[quickhackType] = {
                        name: quickhackNames[quickhackType] || 'unknown',
                        endBlock: endBlock
                    };
                } else {
                    // Keep the earliest end block for this quickhack type
                    groupedEffects[quickhackType].endBlock = Math.min(groupedEffects[quickhackType].endBlock, endBlock);
                }
            });
            
            const effects = Object.values(groupedEffects).map(effect => {
                return `${effect.name} [ends at block ${effect.endBlock}]`;
            });

            // Format recent activity
            const activity = player.activities.map(act => {
                const quickhackName = quickhackNames[act.quickhackType] || '';
                const targetShort = act.target ? act.target.id.slice(0, 6) + '...' + act.target.id.slice(-4) : '';
                
                switch (act.type) {
                    case 'ATTACK':
                        return {
                            html: `⮕ ${quickhackName} <span class="clickable-address" data-address="${act.target.id}" style="cursor: pointer; text-decoration: underline;">${targetShort}</span>`,
                            className: 'attack'
                        };
                    case 'SELF_CAST':
                        return {
                            html: `⬅ ${quickhackName}`,
                            className: 'self-cast'
                        };
                    case 'DEPOSIT':
                        const ethAmount = (parseFloat(act.amount) / 1e18).toFixed(3);
                        return {
                            html: `⬇ ${ethAmount} ETH`,
                            className: 'deposit'
                        };
                    case 'WITHDRAWAL':
                        const ramAmount = Math.floor(parseFloat(act.amount) / 1000);
                        return {
                            html: `⬆ ${ramAmount}K RAM`,
                            className: 'withdrawal'
                        };
                    default:
                        return {
                            html: 'unknown activity',
                            className: ''
                        };
                }
            });

            return {
                address: player.id,
                balance: parseInt(player.currentBalance),
                effects: effects,
                slots: `${activeEffects.length}/9`,
                damageDealt: parseInt(player.damageDealt),
                attackBonus: player.attackBonus,
                damageTaken: parseInt(player.damageTaken),
                defenseBonus: player.defenseBonus,
                deposits: parseFloat(player.totalDeposited).toFixed(3),
                withdrawals: parseInt(player.totalWithdrawn),
                activity: activity
            };
        }

        // Load and populate player list with real data (initial load)
        async function loadAndPopulatePlayerList() {
            const playerData = await fetchActivePlayers(PLAYERS_PER_PAGE, 0);
            players = await Promise.all(playerData.map(formatPlayer));
            playersLoaded = players.length;
            populatePlayerList();
            updateHeaderStats();
            
            // Add scroll listener for lazy loading
            addPlayerListScrollListener();
        }

        // Smart update that preserves user's scroll and expanded states
        async function smartUpdatePlayerList() {
            
            // Save scroll position
            const playerList = document.getElementById('playerList');
            const scrollTop = playerList.scrollTop;
            
            // Save expanded states by player address (more reliable than index)
            const expandedAddresses = new Set();
            document.querySelectorAll('.player-details.expanded').forEach((detail) => {
                const playerAddress = detail.id.replace('player-', '');
                // Find the actual address from the player data
                const playerIndex = parseInt(playerAddress);
                if (players[playerIndex]) {
                    expandedAddresses.add(players[playerIndex].address);
                }
            });
            
            // Only update the currently loaded players (don't reset scroll)
            const currentLoadedCount = players.length;
            const playerData = await fetchActivePlayers(currentLoadedCount, 0);
            
            if (playerData.length > 0) {
                players = await Promise.all(playerData.map(formatPlayer));
                populatePlayerList();
                updateHeaderStats();
                
                // Restore scroll position
                playerList.scrollTop = scrollTop;
                
                // Restore expanded states after DOM rebuild
                setTimeout(() => {
                    expandedAddresses.forEach(address => {
                        // Find the new index for this address
                        const playerIndex = players.findIndex(p => p.address === address);
                        if (playerIndex !== -1) {
                            const playerDetail = document.getElementById(`player-${playerIndex}`);
                            if (playerDetail) {
                                playerDetail.classList.add('expanded');
                                console.log(`Restored expanded state for ${address} at index ${playerIndex}`);
                            }
                        }
                    });
                }, 100);
                
                // Note: Game map no longer auto-updates, uses independent data
            }
        }

        // Load more players (lazy loading)
        async function loadMorePlayers() {
            if (!hasMorePlayers) return;
            
            console.log('Loading more players, skip:', playersLoaded);
            const playerData = await fetchActivePlayers(PLAYERS_PER_PAGE, playersLoaded);
            console.log('Additional player data:', playerData);
            
            if (playerData.length > 0) {
                const newPlayers = await Promise.all(playerData.map(formatPlayer));
                players = [...players, ...newPlayers];
                playersLoaded += newPlayers.length;
                console.log('Total players now:', players.length);
                populatePlayerList();
                updateHeaderStats();
                
                // Note: Game map no longer auto-updates, uses independent data
            }
        }

        // Add scroll listener for lazy loading
        function addPlayerListScrollListener() {
            const playerListContainer = document.querySelector('.player-list');
            if (!playerListContainer) return;
            
            playerListContainer.addEventListener('scroll', () => {
                const { scrollTop, scrollHeight, clientHeight } = playerListContainer;
                
                // Load more when scrolled to within 200px of bottom
                if (scrollTop + clientHeight >= scrollHeight - 200 && hasMorePlayers) {
                    loadMorePlayers();
                }
            });
        }

        // Update header statistics
        function updateHeaderStats() {
            const totalBalance = players.reduce((sum, player) => sum + player.balance, 0);
            document.getElementById('livePlayerCount').textContent = players.length;
            document.getElementById('liveBalance').textContent = totalBalance.toLocaleString() + ' RAM';
        }

        // Populate player list
        function populatePlayerList() {
            const playerList = document.getElementById('playerList');
            
            // Clear existing players before adding updated list
            playerList.innerHTML = '';
            
            players.forEach((player, index) => {
                const playerItem = document.createElement('div');
                playerItem.className = 'player-item';
                playerItem.innerHTML = `
                    <div class="player-header" onclick="togglePlayer(${index})">
                        <span class="player-address clickable-address" data-address="${player.address}" onclick="event.stopPropagation()">${getResponsiveAddress(player.address)}</span>
                        <span class="player-balance">${player.balance.toLocaleString()} RAM</span>
                    </div>
                    <div class="player-details" id="player-${index}">
                        <div class="detail-section">
                            <div class="detail-title">effects [${player.slots} slots]</div>
                            ${player.effects.map(effect => `<div class="effect-item">${effect}</div>`).join('')}
                        </div>
                        
                        <div class="detail-section">
                            <div class="detail-item">⮕ damage dealt     ${player.damageDealt.toLocaleString()} RAM [+${player.attackBonus}]</div>
                            <div class="detail-item">⬅ damage taken     ${player.damageTaken.toLocaleString()} RAM [+${player.defenseBonus}]</div>
                            <div class="detail-item">⬇ deposits         ${player.deposits} ETH</div>
                            <div class="detail-item">⬆ withdrawals      ${player.withdrawals.toLocaleString()} RAM</div>
                        </div>
                        
                        <div class="detail-section">
                            <div class="detail-title">activity</div>
                            ${player.activity.map(activity => `<div class="activity-item ${activity.className}">${activity.html}</div>`).join('')}
                        </div>
                    </div>
                `;
                playerList.appendChild(playerItem);
                
                // Add click handler to the player address
                const addressElement = playerItem.querySelector('.clickable-address');
                addressElement.addEventListener('click', function(event) {
                    event.stopPropagation(); // Prevent toggle player details
                    const targetInput = document.querySelector('.target-input');
                    targetInput.value = this.getAttribute('data-address');
                });
            });

        }

        // Toggle player details
        function togglePlayer(index) {
            const details = document.getElementById(`player-${index}`);
            details.classList.toggle('expanded');
        }

        // Quickhack selection functions
        let currentQuickhackType = 'attack';
        let currentQuickhack = 'short circuit';
        
        // Quickhack slot costs
        const quickhackSlots = {
            'short circuit': 1,
            'overheat': 1,
            'lag': 0,
            'troll': 0,
            'berserk': 2,
            'oilbath': 2,
            'on/off': 1,
            'downstream': 3,
            'icewall': 2
        };
        
        function selectQuickhackType(type) {
            currentQuickhackType = type;
            
            // Update button states
            document.querySelectorAll('.type-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            document.querySelector(`.type-btn.${type}`).classList.add('selected');
            
            // Show/hide options
            document.getElementById('attackOptions').classList.remove('show');
            document.getElementById('selfCastOptions').classList.remove('show');
            
            if (type === 'attack') {
                document.getElementById('attackOptions').classList.add('show');
                // Select first attack option if not already selected
                if (!['short circuit', 'overheat', 'lag', 'troll'].includes(currentQuickhack)) {
                    selectQuickhack('short circuit');
                }
            } else {
                document.getElementById('selfCastOptions').classList.add('show');
                // Select first self-cast option if not already selected
                if (!['berserk', 'oilbath', 'on/off', 'downstream', 'icewall'].includes(currentQuickhack)) {
                    selectQuickhack('berserk');
                }
            }
        }
        
        function selectQuickhack(quickhack) {
            currentQuickhack = quickhack;
            
            console.log('selectQuickhack called with:', quickhack);
            
            // Remove 'selected' class from ALL quickhack buttons
            document.querySelectorAll('.quickhack-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            
            // Find and select the clicked button across all options
            document.querySelectorAll('.quickhack-btn').forEach(btn => {
                if (btn.textContent === quickhack) {
                    btn.classList.add('selected');
                    console.log('Selected button:', btn);
                }
            });
            
            // Update estimated results based on selected quickhack if we have data
            if (connectedWalletAddress && attackerData && targetData) {
                console.log('Auto-recalculating for new quickhack');
                performCalculations();
            }
        }
        
        // Mock updateEstimatedResults function removed - using real calculation function instead

        // Loading bar animation
        function animateLoadingBar() {
            const loadingBar = document.getElementById('loadingBar');
            const binaryChars = ['0', '1'];
            const barLength = 15; // Length to match execute button width
            let progress = 0;
            
            const interval = setInterval(() => {
                let bar = '';
                for (let i = 0; i < barLength; i++) {
                    if (i < progress) {
                        bar += binaryChars[Math.floor(Math.random() * 2)];
                    } else {
                        bar += '.';
                    }
                }
                loadingBar.textContent = `[${bar}]`;
                
                progress++;
                if (progress > barLength) {
                    clearInterval(interval);
                    loadingBar.textContent = `[${'1'.repeat(barLength)}]`;
                }
            }, 150);
        }
        
        // openTxLink function removed - transaction links are now handled by real transaction results
        
        // Disconnect player
        // Player connection state
        let isPlayerConnected = false;
        let connectedWalletAddress = null;

        // GraphQL query for specific player data
        const PLAYER_PROFILE_QUERY = `
            query GetPlayerProfile($address: ID!) {
                player(id: $address) {
                    id
                    currentBalance
                    totalDeposited
                    totalWithdrawn
                    damageDealt
                    damageTaken
                    attackBonus
                    defenseBonus
                    lastDepositBlock
                    withdrawalCooldownEnd
                    activeEffects(where: {isActive: true}) {
                        quickhackType
                        effectType
                        magnitude
                        endBlock
                    }
                    activities(first: 25, orderBy: blockTimestamp, orderDirection: desc) {
                        type
                        target { id }
                        player { id }
                        quickhackType
                        amount
                        blockTimestamp
                    }
                }
                incomingAttacks: activities(
                    first: 25, 
                    orderBy: blockTimestamp, 
                    orderDirection: desc,
                    where: { target: $address, type: ATTACK }
                ) {
                    type
                    target { id }
                    player { id }
                    quickhackType
                    amount
                    blockTimestamp
                }
            }
        `;

        // Fetch specific player data
        async function fetchPlayerProfile(address) {
            try {
                const response = await fetch(SUBGRAPH_URL, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    mode: 'cors',
                    body: JSON.stringify({
                        query: PLAYER_PROFILE_QUERY,
                        variables: { address: address.toLowerCase() }
                    })
                });
                
                const data = await response.json();
                if (data.errors) {
                    console.error('GraphQL errors:', data.errors);
                    return null;
                }
                
                // Store full data globally for activity processing
                window.lastProfileData = data.data;
                
                return data.data.player;
            } catch (error) {
                console.error('Failed to fetch player profile:', error);
                return null;
            }
        }

        // Connect to MetaMask wallet
        async function connectWallet() {
            if (typeof window.ethereum !== 'undefined') {
                try {
                    // Initialize Web3
                    if (!window.ethereum.web3) {
                        window.ethereum.web3 = new Web3(window.ethereum);
                    }
                    
                    // Request account access
                    const accounts = await window.ethereum.request({ 
                        method: 'eth_requestAccounts' 
                    });
                    
                    if (accounts.length > 0) {
                        // Check if we're on Base Sepolia (chainId 84532)
                        const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                        if (chainId !== '0x14a34') { // 84532 in hex
                            try {
                                await window.ethereum.request({
                                    method: 'wallet_switchEthereumChain',
                                    params: [{ chainId: '0x14a34' }],
                                });
                            } catch (switchError) {
                                // Add network if it doesn't exist
                                if (switchError.code === 4902) {
                                    await window.ethereum.request({
                                        method: 'wallet_addEthereumChain',
                                        params: [{
                                            chainId: '0x14a34',
                                            chainName: 'Base Sepolia',
                                            nativeCurrency: {
                                                name: 'ETH',
                                                symbol: 'ETH',
                                                decimals: 18,
                                            },
                                            rpcUrls: ['https://sepolia.base.org'],
                                            blockExplorerUrls: ['https://sepolia.basescan.org/'],
                                        }],
                                    });
                                } else {
                                    throw switchError;
                                }
                            }
                        }
                        
                        connectedWalletAddress = accounts[0];
                        await updatePlayerProfile();
                        setConnectedState();
                        return true;
                    }
                } catch (error) {
                    console.error('Failed to connect wallet:', error);
                    alert('Failed to connect wallet: ' + error.message);
                }
            } else {
                alert('MetaMask not detected. Please install MetaMask to connect your wallet.');
            }
            return false;
        }

        // Update profile with real player data
        async function updatePlayerProfile() {
            if (!connectedWalletAddress) return;
            
            console.log('Fetching profile for:', connectedWalletAddress);
            const playerData = await fetchPlayerProfile(connectedWalletAddress);
            console.log('Player data received:', playerData);
            
            if (playerData) {
                console.log('Using real data, balance:', playerData.currentBalance);
                await populateProfileWithRealData(playerData);
            } else {
                console.log('No player data found, using defaults');
                populateProfileWithNoData();
            }
        }

        // Populate profile with real blockchain data
        async function populateProfileWithRealData(player) {
            const quickhackNames = {
                1: 'short circuit', 2: 'overheat', 3: 'lag', 4: 'troll',
                5: 'berserk', 6: 'oilbath', 7: 'on/off', 8: 'downstream', 9: 'icewall'
            };
            
            // Read cheating death status from contract
            const isCheatingDeath = await getPlayerCheatingDeathStatus(player.id);
            player.isCheatingDeath = isCheatingDeath;

            // Find specific elements by their text content and update them
            const detailItems = document.querySelectorAll('.profile-content .detail-item');
            
            // Update balance and ETH value (first section)
            if (detailItems[0]) {
                detailItems[0].innerHTML = `balance         <span class="ram-value">${parseInt(player.currentBalance).toLocaleString()} RAM</span>`;
            }
            if (detailItems[1]) {
                const ethValue = (parseFloat(player.currentBalance) / 10000000).toFixed(3);
                detailItems[1].innerHTML = `ETH value       ${ethValue} eth`;
            }

            // Update deposits (first detail item in second section)  
            if (detailItems[2]) {
                detailItems[2].innerHTML = `⬇ deposits        ${parseFloat(player.totalDeposited).toFixed(3)} ETH`;
            }

            // Update withdrawals (second detail item in second section)
            if (detailItems[3]) {
                detailItems[3].innerHTML = `⬆ withdrawals     <span class="ram-value">${parseInt(player.totalWithdrawn).toLocaleString()} RAM</span>`;
            }

            // Update withdrawal cooldown (third detail item in second section)
            if (detailItems[4]) {
                const cooldownEndBlock = player.lastDepositBlock ? parseInt(player.lastDepositBlock) + 900 : 'unknown';
                detailItems[4].innerHTML = `withdrawal cooldown ends at block ${cooldownEndBlock.toLocaleString()}`;
            }

            // Update combat stats (third section)
            const totalQuickhacks = player.activities.filter(a => a.type === 'ATTACK' || a.type === 'SELF_CAST').length;
            if (detailItems[5]) {
                detailItems[5].innerHTML = `quickhacks      [${totalQuickhacks}]`;
            }
            if (detailItems[6]) {
                // Calculate total attack bonus including cheating death
                let totalAttackBonus = parseInt(player.attackBonus || 0);
                if (player.isCheatingDeath) {
                    totalAttackBonus += 3000; // 30% bonus
                }
                detailItems[6].innerHTML = `⮕ damage dealt    <span class="ram-value">${parseInt(player.damageDealt).toLocaleString()} RAM</span> [+${totalAttackBonus} attack]`;
            }
            if (detailItems[7]) {
                // Calculate total defense bonus including cheating death
                let totalDefenseBonus = parseInt(player.defenseBonus || 0);
                if (player.isCheatingDeath) {
                    totalDefenseBonus += 3000; // 30% bonus
                }
                detailItems[7].innerHTML = `⬅ damage taken    <span class="ram-value">${parseInt(player.damageTaken).toLocaleString()} RAM</span> [+${totalDefenseBonus} defence]`;
            }

            // Update active effects (fourth section) 
            const effectsContainer = document.querySelector('.profile-content .detail-section:nth-of-type(4)');
            if (effectsContainer) {
                // Filter out expired effects
                const web3 = new Web3(window.ethereum);
                const currentBlockNumber = await web3.eth.getBlockNumber();
                const activeEffects = player.activeEffects.filter(effect => parseInt(effect.endBlock) > currentBlockNumber);
                
                const effectsTitle = effectsContainer.querySelector('.detail-title');
                if (effectsTitle) {
                    effectsTitle.textContent = `active effects [${activeEffects.length}/9 slots]`;
                }
                
                // Clear existing effects
                const existingEffects = effectsContainer.querySelectorAll('.effect-item');
                existingEffects.forEach(el => el.remove());
                
                // Group effects by quickhack type and add new effects
                const groupedEffects = {};
                activeEffects.forEach(effect => {
                    const quickhackType = effect.quickhackType;
                    const endBlock = parseInt(effect.endBlock);
                    
                    if (!groupedEffects[quickhackType]) {
                        groupedEffects[quickhackType] = {
                            name: quickhackNames[quickhackType] || 'unknown',
                            endBlock: endBlock
                        };
                    } else {
                        // Keep the earliest end block for this quickhack type
                        groupedEffects[quickhackType].endBlock = Math.min(groupedEffects[quickhackType].endBlock, endBlock);
                    }
                });
                
                Object.values(groupedEffects).forEach(effect => {
                    const effectDiv = document.createElement('div');
                    effectDiv.className = 'effect-item';
                    effectDiv.textContent = `${effect.name} [ends at block ${effect.endBlock}]`;
                    effectsContainer.appendChild(effectDiv);
                });
            }

            // Update activity feed (fifth section)
            const activityContainer = document.querySelector('.profile-content .detail-section:nth-of-type(5)');
            if (activityContainer) {
                // Clear existing activity
                const existingActivity = activityContainer.querySelectorAll('.activity-item');
                existingActivity.forEach(el => el.remove());
                
                // Get incoming attacks from separate query result
                const incomingAttacks = window.lastProfileData?.incomingAttacks || [];
                
                // Combine outgoing activities and incoming attacks
                const allActivities = [...player.activities, ...incomingAttacks]
                    .sort((a, b) => parseInt(b.blockTimestamp) - parseInt(a.blockTimestamp))
                    .slice(0, 50);
                
                // Add activities
                allActivities.forEach(activity => {
                    const activityDiv = document.createElement('div');
                    activityDiv.className = 'activity-item';
                    
                    const quickhackName = quickhackNames[activity.quickhackType] || '';
                    const isIncoming = activity.target && activity.target.id.toLowerCase() === player.id.toLowerCase();
                    
                    if (isIncoming) {
                        // Incoming attack
                        activityDiv.classList.add('attack');
                        const attackerShort = activity.player.id.slice(0, 6) + '...' + activity.player.id.slice(-4);
                        activityDiv.innerHTML = `⬅ ${quickhackName} from <span class="clickable-address" data-address="${activity.player.id}" style="color: #d42d17; cursor: pointer; text-decoration: underline;">${attackerShort}</span>`;
                    } else {
                        // Outgoing activity
                        const targetShort = activity.target ? activity.target.id.slice(0, 6) + '...' + activity.target.id.slice(-4) : '';
                        
                        switch (activity.type) {
                            case 'ATTACK':
                                activityDiv.classList.add('attack');
                                activityDiv.innerHTML = `⮕ ${quickhackName} <span class="clickable-address" data-address="${activity.target.id}" style="color: #d42d17; cursor: pointer; text-decoration: underline;">${targetShort}</span>`;
                                break;
                            case 'SELF_CAST':
                                activityDiv.classList.add('self-cast');
                                activityDiv.textContent = `⬅ ${quickhackName}`;
                                break;
                            case 'DEPOSIT':
                                const ethAmount = (parseFloat(activity.amount) / 1e18).toFixed(3);
                                activityDiv.textContent = `⬇ ${ethAmount} ETH`;
                                break;
                            case 'WITHDRAWAL':
                                const ramAmount = Math.floor(parseFloat(activity.amount) / 1000);
                                activityDiv.textContent = `⬆ ${ramAmount}K RAM`;
                                break;
                        }
                    }
                    
                    activityContainer.appendChild(activityDiv);
                });
            }
        }

        // Populate profile when no data exists
        function populateProfileWithNoData() {
            const detailItems = document.querySelectorAll('.profile-content .detail-item');
            
            // Update with zero values
            if (detailItems[0]) {
                detailItems[0].innerHTML = `balance         <span class="ram-value">0 RAM</span>`;
            }
            if (detailItems[1]) {
                detailItems[1].innerHTML = `ETH value       0.000 eth`;
            }
            if (detailItems[2]) {
                detailItems[2].innerHTML = `⬇ deposits        0.000 ETH`;
            }
            if (detailItems[3]) {
                detailItems[3].innerHTML = `⬆ withdrawals     <span class="ram-value">0 RAM</span>`;
            }
            if (detailItems[4]) {
                detailItems[4].innerHTML = `withdrawal cooldown ends at block unknown`;
            }
            if (detailItems[5]) {
                detailItems[5].innerHTML = `quickhacks      [0]`;
            }
            if (detailItems[6]) {
                detailItems[6].innerHTML = `⮕ damage dealt    <span class="ram-value">0 RAM</span> [+0 attack]`;
            }
            if (detailItems[7]) {
                detailItems[7].innerHTML = `⬅ damage taken    <span class="ram-value">0 RAM</span> [+0 defence]`;
            }

            // Clear effects and activity
            const effectsContainer = document.querySelector('.profile-content .detail-section:nth-of-type(4)');
            if (effectsContainer) {
                const effectsTitle = effectsContainer.querySelector('.detail-title');
                if (effectsTitle) {
                    effectsTitle.textContent = `active effects [0/9 slots]`;
                }
                effectsContainer.querySelectorAll('.effect-item').forEach(el => el.remove());
            }

            const activityContainer = document.querySelector('.profile-content .detail-section:nth-of-type(5)');
            if (activityContainer) {
                activityContainer.querySelectorAll('.activity-item').forEach(el => el.remove());
                
                const noActivityDiv = document.createElement('div');
                noActivityDiv.className = 'activity-item';
                noActivityDiv.textContent = 'no activity found';
                activityContainer.appendChild(noActivityDiv);
            }
        }

        // Set UI to connected state
        function setConnectedState() {
            const profileTitle = document.getElementById('profileTitle');
            const connectBtn = document.getElementById('connectDisconnectBtn');
            const profileSection = document.getElementById('profileSection');
            const profileDisconnected = document.getElementById('profileDisconnected');
            const pfpSection = document.getElementById('pfpSection');
            const pfpLoading = document.getElementById('pfpLoading');
            
            profileTitle.textContent = `PLAYER ${getResponsiveAddress(connectedWalletAddress)}`;
            connectBtn.textContent = 'x';
            profileSection.style.display = 'block';
            profileDisconnected.classList.remove('show');
            
            // Show PFP and initialize it
            pfpSection.style.display = 'block';
            pfpLoading.style.display = 'none';
            
            // Initialize PFP from external module
            initializePFP();
            
            isPlayerConnected = true;
        }

        // Set UI to disconnected state
        function setDisconnectedState() {
            const profileTitle = document.getElementById('profileTitle');
            const connectBtn = document.getElementById('connectDisconnectBtn');
            const profileSection = document.getElementById('profileSection');
            const profileDisconnected = document.getElementById('profileDisconnected');
            const pfpSection = document.getElementById('pfpSection');
            const pfpLoading = document.getElementById('pfpLoading');
            
            profileTitle.textContent = 'PLAYER';
            connectBtn.textContent = 'connect';
            profileSection.style.display = 'none';
            profileDisconnected.classList.add('show');
            
            // Hide PFP
            pfpSection.style.display = 'none';
            pfpLoading.style.display = 'flex';
            pfpLoading.querySelector('.loading-text').textContent = 'no player connected';
            pfpLoading.querySelector('.loading-bar-container').style.display = 'none';
            
            // Reset PFP seed display
            document.getElementById('seedDisplay').textContent = 'no player connected';
            
            isPlayerConnected = false;
            connectedWalletAddress = null;
            
            // Reset estimated results
            updateEstimatedResults('[connect]', '[connect]');
        }

        async function togglePlayerConnection() {
            if (isPlayerConnected) {
                // Disconnect wallet
                setDisconnectedState();
            } else {
                // Connect wallet
                await connectWallet();
            }
        }

        async function executeDeposit() {
            const amount = document.getElementById('depositAmount').value;
            if (!amount || parseFloat(amount) <= 0) {
                alert('Please enter a valid deposit amount');
                return;
            }
            
            if (!connectedWalletAddress) {
                alert('Please connect your wallet first');
                return;
            }
            
            try {
                // Validate and format amount
                const ethAmount = parseFloat(amount);
                const weiAmount = (ethAmount * 1e18).toString();
                
                // Get contract instance
                const web3 = new Web3(window.ethereum);
                const contract = new web3.eth.Contract(QUICKHACKS_GAME_ABI, QUICKHACKS_GAME_ADDRESS);
                
                // Call deposit function
                const tx = await contract.methods.deposit().send({
                    from: connectedWalletAddress,
                    value: weiAmount,
                    gas: 200000
                });
                
                // Show transaction success message with link
                const statusDiv = document.getElementById('transactionStatus');
                statusDiv.innerHTML = `✅ deposit successful: <a href="https://sepolia.basescan.org/tx/${tx.transactionHash}" target="_blank" style="color: #ceccde; text-decoration: underline;">${tx.transactionHash.slice(0, 10)}...${tx.transactionHash.slice(-8)}</a>`;
                statusDiv.style.display = 'block';
                
                // Clear input (don't refresh profile due to subgraph delay)
                document.getElementById('depositAmount').value = '';
                
            } catch (error) {
                console.error('Deposit failed:', error);
                alert(`Deposit failed: ${error.message || 'Unknown error'}`);
            }
        }

        async function executeWithdraw() {
            const amount = document.getElementById('withdrawAmount').value;
            if (!amount || parseInt(amount) <= 0) {
                alert('Please enter a valid withdrawal amount');
                return;
            }
            
            if (!connectedWalletAddress) {
                alert('Please connect your wallet first');
                return;
            }
            
            try {
                // Convert RAM amount to proper format
                const ramAmount = parseInt(amount);
                
                // Get contract instance
                const web3 = new Web3(window.ethereum);
                const contract = new web3.eth.Contract(QUICKHACKS_GAME_ABI, QUICKHACKS_GAME_ADDRESS);
                
                // Call withdraw function
                const tx = await contract.methods.withdraw(ramAmount.toString()).send({
                    from: connectedWalletAddress,
                    gas: 300000
                });
                
                // Show transaction success message with link
                const statusDiv = document.getElementById('transactionStatus');
                statusDiv.innerHTML = `✅ withdrawal successful: <a href="https://sepolia.basescan.org/tx/${tx.transactionHash}" target="_blank" style="color: #ceccde; text-decoration: underline;">${tx.transactionHash.slice(0, 10)}...${tx.transactionHash.slice(-8)}</a>`;
                statusDiv.style.display = 'block';
                
                // Clear input (don't refresh profile due to subgraph delay)
                document.getElementById('withdrawAmount').value = '';
                
            } catch (error) {
                console.error('Withdrawal failed:', error);
                alert(`Withdrawal failed: ${error.message || 'Unknown error'}`);
            }
        }
        
        // Execute quickhack with real contract interaction
        async function executeAttack() {
            const resultSection = document.getElementById('resultSection');
            const button = document.querySelector('.execute-btn');
            const loadingContainer = document.getElementById('loadingContainer');
            const targetAddress = document.getElementById('targetAddressInput').value.trim();
            
            // Validation
            if (!connectedWalletAddress) {
                alert('Please connect your wallet first');
                return;
            }
            
            if (!currentQuickhack) {
                alert('Please select a quickhack first');
                return;
            }
            
            // Validate target address for attacks
            if (currentQuickhackType === 'attack') {
                if (!targetAddress) {
                    alert('Please enter a target address for attacks');
                    return;
                }
                if (!targetAddress.startsWith('0x') || targetAddress.length !== 42) {
                    alert('Please enter a valid Ethereum address');
                    return;
                }
                if (targetAddress.toLowerCase() === connectedWalletAddress.toLowerCase()) {
                    alert('Cannot attack yourself. Use self-cast quickhacks instead.');
                    return;
                }
            }
            
            // Validate for self-cast (should target own address)
            const finalTarget = currentQuickhackType === 'self-cast' ? connectedWalletAddress : targetAddress;
            
            try {
                // Disable button and show loading
                button.textContent = 'sending transaction...';
                button.disabled = true;
                loadingContainer.classList.add('show');
                animateLoadingBar();
                
                // Get quickhack ID
                const quickhackId = QUICKHACK_IDS[currentQuickhack];
                if (!quickhackId) {
                    throw new Error(`Unknown quickhack: ${currentQuickhack}`);
                }
                
                // Get contract instance
                const web3 = new Web3(window.ethereum);
                const contract = new web3.eth.Contract(QUICKHACKS_GAME_ABI, QUICKHACKS_GAME_ADDRESS);
                
                // Call executeQuickhack function
                const tx = await contract.methods.executeQuickhack(quickhackId, finalTarget).send({
                    from: connectedWalletAddress,
                    gas: 500000 // Higher gas limit for quickhack execution
                });
                
                // Update result section with success
                const results = document.querySelectorAll('#resultSection .detail-item');
                
                // Build quickhack result text
                let quickhackText = '';
                if (currentQuickhackType === 'attack') {
                    quickhackText = `<span class="quickhack-attack">${currentQuickhack} ⮕ ${targetAddress}</span>`;
                } else {
                    quickhackText = `<span class="quickhack-self-cast">${currentQuickhack} ⬅</span>`;
                }
                
                results[0].textContent = 'successful';
                results[1].innerHTML = quickhackText;
                results[2].innerHTML = `<a href="https://sepolia.basescan.org/tx/${tx.transactionHash}" target="_blank" style="color: #ceccde; text-decoration: underline;">${tx.transactionHash.slice(0, 10)}...${tx.transactionHash.slice(-8)}</a>`;
                results[3].innerHTML = 'database update in ~1 minute (waiting for events sync)';
                results[4].innerHTML = '';
                
                // Note: Activity will appear in feed once subgraph syncs (~2 minutes)
                
                resultSection.classList.add('show');
                
            } catch (error) {
                console.error('Quickhack execution failed:', error);
                
                // Parse contract error message
                let userFriendlyMessage = 'Unknown error';
                let txHash = null;
                
                if (error.message) {
                    // Extract contract revert reason
                    if (error.message.includes('Quickhack not allowed')) {
                        userFriendlyMessage = 'Quickhack blocked (protection, immunity, or game rules)';
                    } else if (error.message.includes('Insufficient balance')) {
                        userFriendlyMessage = 'Insufficient RAM balance';
                    } else if (error.message.includes('Balance requirement not met')) {
                        userFriendlyMessage = 'Balance requirement not met (need 10% of target balance)';
                    } else if (error.message.includes('Rate limit')) {
                        userFriendlyMessage = 'Rate limit: wait until next block';
                    } else if (error.message.includes('Game is paused')) {
                        userFriendlyMessage = 'Game is currently paused';
                    } else if (error.message.includes('Address is banned')) {
                        userFriendlyMessage = 'Your address is banned from attacks';
                    } else if (error.message.includes('Withdrawal cooldown')) {
                        userFriendlyMessage = 'Withdrawal cooldown active';
                    } else if (error.message.includes('Effect limit reached')) {
                        userFriendlyMessage = 'Target has maximum effects (9/9 slots)';
                    } else if (error.message.includes('User denied transaction')) {
                        userFriendlyMessage = 'Transaction cancelled by user';
                    } else if (error.message.includes('insufficient funds')) {
                        userFriendlyMessage = 'Insufficient ETH for gas fees';
                    } else {
                        // For other errors, show a simplified version
                        userFriendlyMessage = 'Transaction failed - check contract rules';
                    }
                    
                    // Try to extract transaction hash if available
                    const txHashMatch = error.message.match(/0x[a-fA-F0-9]{64}/);
                    if (txHashMatch) {
                        txHash = txHashMatch[0];
                    }
                }
                
                // Update result section with clean error
                const results = document.querySelectorAll('#resultSection .detail-item');
                results[0].innerHTML = `<span style="color: #ff5555;">${currentQuickhack} failed</span>`;
                results[1].innerHTML = txHash ? `<a href="https://sepolia.basescan.org/tx/${txHash}" target="_blank" style="color: #ceccde; text-decoration: underline;">${txHash.slice(0, 10)}...${txHash.slice(-8)}</a>` : 'no transaction sent';
                results[2].innerHTML = `<span style="color: #ff5555;">${userFriendlyMessage}</span>`;
                results[3].textContent = '';
                results[4].textContent = '';
                
                resultSection.classList.add('show');
            } finally {
                // Re-enable button and hide loading
                button.textContent = 'execute quickhack';
                button.disabled = false;
                loadingContainer.classList.remove('show');
            }
        }

        // GraphQL endpoint for subgraph (secure proxy)
        const SUBGRAPH_URL = 'https://quickhacks-api.vercel.app/api/subgraph';
        
        // Contract configuration
        const QUICKHACKS_GAME_ADDRESS = '0x9DAE86aAc4E77432D4Bc84ed0F571E4B56448e2D';
        const QUICKHACK_SYSTEM_ADDRESS = '0x951F03D95DbE47c7Be0B24a3cBb8719e39661352';
        const PLAYER_MANAGER_ADDRESS = '0xD1Bf4a4b0E57c2Baa69A4d806Ab1Ea9554A01aA3';
        
        const QUICKHACKS_GAME_ABI = [
            {
                "inputs": [],
                "name": "deposit",
                "outputs": [],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "amount",
                        "type": "uint256"
                    }
                ],
                "name": "withdraw",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint8",
                        "name": "quickhackType",
                        "type": "uint8"
                    },
                    {
                        "internalType": "address",
                        "name": "target",
                        "type": "address"
                    }
                ],
                "name": "executeQuickhack",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            }
        ];
        
        // QuickhackSystem ABI (minimal for reading game state)
        const QUICKHACK_SYSTEM_ABI = [
            {
                "inputs": [],
                "name": "getCurrentGameState",
                "outputs": [
                    {"internalType": "uint8", "name": "", "type": "uint8"},
                    {"internalType": "uint256", "name": "", "type": "uint256"}
                ],
                "stateMutability": "view",
                "type": "function"
            }
        ];
        
        // PlayerManager ABI (minimal for reading cheating death status)
        const PLAYER_MANAGER_ABI = [
            {
                "inputs": [{"internalType": "address", "name": "player", "type": "address"}],
                "name": "isCheatingDeath",
                "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
                "stateMutability": "view",
                "type": "function"
            }
        ];
        
        // Boss address for balance tracking
        const BOSS_ADDRESS = '0x05351d48D04E16b05e388394e6AbB25054D0Ad5a';
        
        // Quickhack name to ID mapping (from contract constants)
        const QUICKHACK_IDS = {
            'short circuit': 1,
            'overheat': 2,
            'lag': 3,
            'troll': 4,
            'berserk': 5,
            'oilbath': 6,
            'on/off': 7,
            'downstream': 8,
            'icewall': 9
        };
        
        // GraphQL query for boss balance
        const BOSS_BALANCE_QUERY = `
            query GetBossBalance($bossAddress: String!) {
                player(id: $bossAddress) {
                    id
                    currentBalance
                }
            }
        `;
        
        // Function to load boss balance
        async function loadBossBalance() {
            try {
                const response = await fetch(SUBGRAPH_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        query: BOSS_BALANCE_QUERY,
                        variables: { bossAddress: BOSS_ADDRESS.toLowerCase() }
                    })
                });
                
                const data = await response.json();
                
                if (data.errors) {
                    console.error('GraphQL errors:', data.errors);
                    return;
                }
                
                const player = data.data.player;
                if (player && player.currentBalance) {
                    // Format balance with commas
                    const balance = parseInt(player.currentBalance);
                    const formattedBalance = balance.toLocaleString();
                    document.querySelector('.boss-balance').textContent = `${formattedBalance} RAM`;
                } else {
                    // Boss hasn't played yet, show 0
                    document.querySelector('.boss-balance').textContent = '0 RAM';
                }
            } catch (error) {
                console.error('Error loading boss balance:', error);
            }
        }
        
        // Function to load current Base Sepolia block number
        async function loadCurrentBlock() {
            
            // Try MetaMask first if available and connected to Base Sepolia
            if (window.ethereum && connectedWalletAddress) {
                try {
                    const web3 = new Web3(window.ethereum);
                    const currentChainId = await web3.eth.getChainId();
                    
                    if (currentChainId === 84532) { // Base Sepolia
                        const blockNumber = await web3.eth.getBlockNumber();
                        const formattedBlock = blockNumber.toLocaleString();
                        document.getElementById('currentBlock').textContent = formattedBlock;
                        return;
                    }
                } catch (error) {
                }
            }
            
            // Fallback to public RPC
            try {
                const response = await fetch('https://sepolia.base.org', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        method: 'eth_blockNumber',
                        params: [],
                        id: 1
                    })
                });
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Response data:', data);
                
                if (data.result) {
                    const blockNumber = parseInt(data.result, 16);
                    const formattedBlock = blockNumber.toLocaleString();
                    console.log('Block number:', blockNumber, 'formatted:', formattedBlock);
                    document.getElementById('currentBlock').textContent = formattedBlock;
                } else if (data.error) {
                    console.error('RPC error:', data.error);
                    document.getElementById('currentBlock').textContent = 'rpc error';
                } else {
                    document.getElementById('currentBlock').textContent = 'no data';
                }
            } catch (error) {
                console.error('Error loading current block:', error);
                document.getElementById('currentBlock').textContent = 'unavailable';
            }
        }
        
        // Function to load Base Sepolia gas price
        async function loadGasPrice() {
            console.log('Loading gas price...');
            
            // Try MetaMask first if available and connected to Base Sepolia
            if (window.ethereum && connectedWalletAddress) {
                try {
                    console.log('Trying MetaMask for gas price...');
                    const web3 = new Web3(window.ethereum);
                    const currentChainId = await web3.eth.getChainId();
                    
                    if (currentChainId === 84532) { // Base Sepolia
                        const gasPriceWei = await web3.eth.getGasPrice();
                        const gasPriceGwei = parseInt(gasPriceWei) / 1000000000;
                        console.log('Gas price from MetaMask:', gasPriceWei, 'wei =', gasPriceGwei, 'gwei');
                        
                        if (gasPriceGwei < 0.01) {
                            document.getElementById('gasPrice').textContent = '<0.01 gwei';
                        } else {
                            document.getElementById('gasPrice').textContent = `${gasPriceGwei.toFixed(3)} gwei`;
                        }
                        return;
                    }
                } catch (error) {
                    console.log('MetaMask gas price failed:', error);
                }
            }
            
            // Fallback to public RPC
            try {
                const response = await fetch('https://sepolia.base.org', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        method: 'eth_gasPrice',
                        params: [],
                        id: 1
                    })
                });
                
                const data = await response.json();
                console.log('Gas price response:', data);
                
                if (data.result) {
                    const gasPriceWei = parseInt(data.result, 16);
                    const gasPriceGwei = gasPriceWei / 1000000000;
                    console.log('Gas price:', gasPriceWei, 'wei =', gasPriceGwei, 'gwei');
                    
                    if (gasPriceGwei < 0.01) {
                        document.getElementById('gasPrice').textContent = '<0.01 gwei';
                    } else {
                        document.getElementById('gasPrice').textContent = `${gasPriceGwei.toFixed(3)} gwei`;
                    }
                } else {
                    document.getElementById('gasPrice').textContent = '~0.1 gwei';
                }
            } catch (error) {
                console.error('Error loading gas price:', error);
                document.getElementById('gasPrice').textContent = '~0.1 gwei';
            }
        }
        
        // Track last activity timestamp to avoid duplicates
        let lastActivityTimestamp = 0;

        // Function to set target address in attack simulator
        function setTargetAddress(address) {
            const targetInput = document.getElementById('targetAddressInput');
            if (targetInput) {
                targetInput.value = address;
                console.log('Set target to:', address);
            }
        }

        // GraphQL query for target player data in attack simulator
        const TARGET_PLAYER_QUERY = `
            query GetTargetPlayer($playerAddress: String!) {
                player(id: $playerAddress) {
                    id
                    currentBalance
                    damageDealt
                    damageTaken
                    attackBonus
                    defenseBonus
                    activeEffects(where: {isActive: true}) {
                        id
                        quickhackType
                        endBlock
                        magnitude
                        effectType
                        isActive
                    }
                }
            }
        `;

        // Function to refresh target data for attack simulator
        async function refreshTargetData() {
            const targetInput = document.getElementById('targetAddressInput');
            const targetAddress = targetInput.value.trim().toLowerCase();
            
            if (!targetAddress) {
                alert('Please enter a target address');
                return;
            }
            
            // Validate address format
            if (!targetAddress.match(/^0x[a-fA-F0-9]{40}$/)) {
                alert('Please enter a valid Ethereum address (0x...)');
                return;
            }
            
            console.log('Refreshing target data for:', targetAddress);
            
            // Show loading states
            document.getElementById('targetBalance').textContent = 'loading...';
            document.getElementById('targetDefense').textContent = 'loading...';
            document.getElementById('targetAttack').textContent = 'loading...';
            document.getElementById('effectsTitle').textContent = 'effects [loading...]';
            document.getElementById('effectsList').innerHTML = '<div class="effect-item">Loading effects...</div>';
            
            try {
                const response = await fetch(SUBGRAPH_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        query: TARGET_PLAYER_QUERY,
                        variables: { playerAddress: targetAddress }
                    })
                });
                
                console.log('Response status:', response.status);
                console.log('Response headers:', response.headers);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Full response data:', data);
                
                if (data.errors) {
                    console.error('GraphQL errors:', data.errors);
                    displayTargetError(`GraphQL error: ${data.errors[0].message}`);
                    return;
                }
                
                const player = data.data.player;
                
                if (!player) {
                    // Player not found in subgraph (hasn't played yet)
                    displayTargetNotFound();
                    
                    // Also calculate estimated results with default target data if wallet is connected
                    if (connectedWalletAddress) {
                        targetData = {
                            currentBalance: '0',
                            attackBonus: 0,
                            defenseBonus: 0,
                            activeEffects: []
                        };
                        refreshAttackerDataAndCalculate();
                    }
                    return;
                }
                
                // Display the player data
                await displayTargetData(player);
                
                // Also calculate estimated results if wallet is connected
                if (connectedWalletAddress) {
                    // Set the target data for calculations
                    targetData = player;
                    // Get attacker data and calculate
                    refreshAttackerDataAndCalculate();
                }
                
            } catch (error) {
                console.error('Error loading target data:', error);
                displayTargetError('Network error');
            }
        }
        
        // Function to display target player data
        async function displayTargetData(player) {
            // Read cheating death status from contract
            const isCheatingDeath = await getPlayerCheatingDeathStatus(player.id);
            player.isCheatingDeath = isCheatingDeath;
            
            // Balance
            const balance = parseInt(player.currentBalance);
            document.getElementById('targetBalance').textContent = `${balance.toLocaleString()} RAM`;
            
            // Bonuses (calculate from damage stats like in player manager)
            let attackBonus = player.attackBonus || 0;
            let defenseBonus = player.defenseBonus || 0;
            
            // Add cheating death bonuses if applicable
            if (isCheatingDeath) {
                attackBonus += 3000; // 30%
                defenseBonus += 3000; // 30%
            }
            
            document.getElementById('targetAttack').textContent = `+${attackBonus}`;
            document.getElementById('targetDefense').textContent = `+${defenseBonus}`;
            
            // Effects - filter out expired effects
            const effects = player.activeEffects || [];
            const web3 = new Web3(window.ethereum);
            const currentBlockNumber = await web3.eth.getBlockNumber();
            const activeEffects = effects.filter(effect => parseInt(effect.endBlock) > currentBlockNumber);
            const effectsCount = activeEffects.length;
            document.getElementById('effectsTitle').textContent = `effects [${effectsCount}/9 slots]`;
            
            if (effectsCount === 0) {
                document.getElementById('effectsList').innerHTML = '<div class="effect-item">No active effects</div>';
            } else {
                // Map quickhack types to names (from contract constants 1-9)
                const quickhackNames = {
                    1: 'SHORT CIRCUIT',
                    2: 'OVERHEAT', 
                    3: 'LAG',
                    4: 'TROLL',
                    5: 'BERSERK',
                    6: 'OILBATH',
                    7: 'ONOFF',
                    8: 'DOWNSTREAM',
                    9: 'ICEWALL'
                };
                
                // Get current block number for filtering expired effects
                const web3 = new Web3(window.ethereum);
                const currentBlockNumber = await web3.eth.getBlockNumber();
                
                // Use the already filtered active effects
                
                const groupedEffects = {};
                activeEffects.forEach(effect => {
                    const quickhackType = effect.quickhackType;
                    const endBlock = parseInt(effect.endBlock);
                    
                    if (!groupedEffects[quickhackType]) {
                        groupedEffects[quickhackType] = {
                            name: quickhackNames[quickhackType] || `unknown-${quickhackType}`,
                            endBlock: endBlock
                        };
                    } else {
                        // Keep the earliest end block for this quickhack type
                        groupedEffects[quickhackType].endBlock = Math.min(groupedEffects[quickhackType].endBlock, endBlock);
                    }
                });
                
                const effectsHtml = Object.values(groupedEffects).map(effect => {
                    return `<div class="effect-item">${effect.name} [ends at block ${effect.endBlock}]</div>`;
                }).join('');
                
                document.getElementById('effectsList').innerHTML = effectsHtml;
            }
            
            console.log('Target data loaded successfully:', player);
        }
        
        // Function to display when target player not found
        function displayTargetNotFound() {
            document.getElementById('targetBalance').textContent = '0 RAM';
            document.getElementById('targetDefense').textContent = '+0';
            document.getElementById('targetAttack').textContent = '+0';
            document.getElementById('effectsTitle').textContent = 'effects [0/9 slots]';
            document.getElementById('effectsList').innerHTML = '<div class="effect-item">Player not found (hasn\'t played yet)</div>';
        }
        
        // Function to display error state
        function displayTargetError(message) {
            document.getElementById('targetBalance').textContent = 'error';
            document.getElementById('targetDefense').textContent = 'error';
            document.getElementById('targetAttack').textContent = 'error';
            document.getElementById('effectsTitle').textContent = 'effects [error]';
            document.getElementById('effectsList').innerHTML = `<div class="effect-item">Error: ${message}</div>`;
        }

        // Quickhack parameters (from contract)
        const QUICKHACK_PARAMS = {
            1: { // SHORT CIRCUIT
                baseDamage: 300,        // 3%
                costDamageRatio: 5000,  // 50%
                effectMagnitude: 2000,  // +20% attack costs
                durationBlocks: 450,
                effectType: 3, // ATTACK_COST_MOD
                selfCastOnly: false
            },
            2: { // OVERHEAT
                baseDamage: 250,        // 2.5%
                costDamageRatio: 6000,  // 60%
                effectMagnitude: 2500,  // -25% defense
                durationBlocks: 450,
                effectType: 2, // DEFENSE_MOD
                selfCastOnly: false
            },
            3: { // LAG
                baseDamage: 30,         // 0.3%
                costDamageRatio: 3333,  // ~33%
                effectMagnitude: 0,
                durationBlocks: 0,
                effectType: 5, // SPECIAL
                selfCastOnly: false
            },
            4: { // TROLL
                baseDamage: 100,        // 1%
                costDamageRatio: 10000, // 100%
                effectMagnitude: 0,
                durationBlocks: 0,
                effectType: 5, // SPECIAL
                selfCastOnly: false
            },
            5: { // BERSERK
                baseDamage: 0,
                costDamageRatio: 0,
                effectMagnitude: 10000, // +100% attack damage
                durationBlocks: 600,
                effectType: 1, // ATTACK_DAMAGE_MOD
                selfCastOnly: true,
                fixedCostPercent: 300   // 3%
            },
            6: { // OILBATH
                baseDamage: 0,
                costDamageRatio: 0,
                effectMagnitude: 3000,  // -30% attack costs
                durationBlocks: 900,
                effectType: 3, // ATTACK_COST_MOD
                selfCastOnly: true,
                fixedCostPercent: 200   // 2%
            },
            7: { // ONOFF
                baseDamage: 0,
                costDamageRatio: 0,
                effectMagnitude: 10000, // Full protection
                durationBlocks: 300,
                effectType: 4, // PROTECTION
                selfCastOnly: true,
                fixedCostPercent: 200   // 2%
            },
            8: { // DOWNSTREAM
                baseDamage: 0,
                costDamageRatio: 0,
                effectMagnitude: 5000,  // +50% defense
                durationBlocks: 600,
                effectType: 2, // DEFENSE_MOD
                selfCastOnly: true,
                fixedCostPercent: 200   // 2%
            },
            9: { // ICEWALL
                baseDamage: 0,
                costDamageRatio: 0,
                effectMagnitude: 10000, // +100% defense
                durationBlocks: 600,
                effectType: 2, // DEFENSE_MOD
                selfCastOnly: true,
                fixedCostPercent: 200   // 2%
            }
        };

        // Current player data cache
        let attackerData = null;
        let targetData = null;
        let currentBlockNumber = null;

        // Function to get current block number for effect validation
        async function getCurrentBlockNumber() {
            if (window.ethereum && connectedWalletAddress) {
                try {
                    const web3 = new Web3(window.ethereum);
                    const currentChainId = await web3.eth.getChainId();
                    if (currentChainId === 84532) { // Base Sepolia
                        return await web3.eth.getBlockNumber();
                    }
                } catch (error) {
                    console.log('MetaMask block fetch failed:', error);
                }
            }
            
            // Fallback to RPC
            try {
                const response = await fetch('https://sepolia.base.org', {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    mode: 'cors',
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        method: 'eth_blockNumber',
                        params: [],
                        id: 1
                    })
                });
                const data = await response.json();
                if (data.result) {
                    return parseInt(data.result, 16);
                }
            } catch (error) {
                console.error('Block number fetch failed:', error);
            }
            return null;
        }
        
        // Function to read game state from QuickhackSystem contract
        async function getContractGameState() {
            try {
                if (window.ethereum) {
                    const web3 = new Web3(window.ethereum);
                    const contract = new web3.eth.Contract(QUICKHACK_SYSTEM_ABI, QUICKHACK_SYSTEM_ADDRESS);
                    const result = await contract.methods.getCurrentGameState().call();
                    
                    // result[0] = state (0=Normal, 1=Outage, 2=Underload, 3=Full Moon)
                    // result[1] = modifier value (basis points)
                    return {
                        state: parseInt(result[0]),
                        modifier: parseInt(result[1])
                    };
                } else {
                    console.log('No ethereum provider available');
                    return { state: 0, modifier: 0 };
                }
            } catch (error) {
                console.error('Failed to read game state:', error);
                return { state: 0, modifier: 0 }; // Default to normal
            }
        }
        
        // Function to check if a player has cheating death status
        async function getPlayerCheatingDeathStatus(playerAddress) {
            try {
                if (window.ethereum && playerAddress) {
                    const web3 = new Web3(window.ethereum);
                    const contract = new web3.eth.Contract(PLAYER_MANAGER_ABI, PLAYER_MANAGER_ADDRESS);
                    const isCheatingDeath = await contract.methods.isCheatingDeath(playerAddress).call();
                    return Boolean(isCheatingDeath);
                } else {
                    return false;
                }
            } catch (error) {
                console.error('Failed to read cheating death status:', error);
                return false;
            }
        }
        
        // Function to update game state display in header
        async function updateGameStateDisplay() {
            try {
                const gameState = await getContractGameState();
                const gameStateElement = document.querySelector('.header-item:nth-child(4) .header-value');
                
                let stateText = 'normal';
                switch (gameState.state) {
                    case 0:
                        stateText = 'normal';
                        break;
                    case 1:
                        stateText = 'outage';
                        break;
                    case 2:
                        const reductionPercent = Math.round(gameState.modifier / 100);
                        stateText = `underload (-${reductionPercent}%)`;
                        break;
                    case 3:
                        const increasePercent = Math.round(gameState.modifier / 100);
                        stateText = `full moon (+${increasePercent}%)`;
                        break;
                }
                
                if (gameStateElement) {
                    gameStateElement.textContent = stateText;
                }
                
                console.log('Game state updated:', stateText);
                return gameState;
            } catch (error) {
                console.error('Failed to update game state display:', error);
                return { state: 0, modifier: 0 };
            }
        }
        
        // Function to apply game state modifier to damage/cost
        function applyGameStateModifier(value, gameState) {
            if (!gameState) return value;
            
            switch (gameState.state) {
                case 2: // Underload - decrease
                    return Math.floor(value * (10000 - gameState.modifier) / 10000);
                case 3: // Full Moon - increase
                    return Math.floor(value * (10000 + gameState.modifier) / 10000);
                default: // Normal or Outage - no change
                    return value;
            }
        }
        
        // Function to refresh game state and recalculate attack simulator  
        async function refreshGameStateAndCalculations() {
            try {
                console.log('Refreshing game state and calculations...');
                
                // Update game state display and store globally
                window.currentGameState = await updateGameStateDisplay();
                
                // If attack simulator has data, recalculate with new game state
                if (connectedWalletAddress && attackerData) {
                    await refreshAttackerDataAndCalculate();
                }
                
                console.log('Game state refresh complete:', window.currentGameState);
            } catch (error) {
                console.error('Failed to refresh game state:', error);
            }
        }

        // Function to filter active effects based on current block
        function getActiveEffects(effects, currentBlock) {
            if (!effects || !currentBlock) return [];
            return effects.filter(effect => {
                const endBlock = parseInt(effect.endBlock);
                return currentBlock < endBlock;
            });
        }

        // Function to calculate effect bonus for a specific type
        function calculateEffectBonus(effects, effectType, currentBlock) {
            const activeEffects = getActiveEffects(effects, currentBlock);
            let totalBonus = 0;
            
            for (const effect of activeEffects) {
                if (effect.effectType == effectType) {
                    const magnitude = parseInt(effect.magnitude);
                    const quickhackType = parseInt(effect.quickhackType);
                    
                    // OVERHEAT and OILBATH have negative effects on defense and costs respectively
                    if ((quickhackType === 2 && effectType === 2) || // OVERHEAT reduces defense
                        (quickhackType === 6 && effectType === 3)) {  // OILBATH reduces attack costs
                        totalBonus -= magnitude;
                    } else {
                        totalBonus += magnitude;
                    }
                }
            }
            
            return totalBonus;
        }

        // Function to refresh both attacker and target data for calculations
        async function refreshBothPlayersData() {
            if (!connectedWalletAddress) {
                updateEstimatedResults('[connect]', '[connect]');
                return false;
            }

            const targetInput = document.getElementById('targetAddressInput');
            const targetAddress = targetInput.value.trim().toLowerCase();
            
            if (!targetAddress || !targetAddress.match(/^0x[a-fA-F0-9]{40}$/)) {
                updateEstimatedResults('enter target', 'enter target');
                return false;
            }

            console.log('Refreshing both players data...');
            updateEstimatedResults('loading...', 'loading...');

            try {
                // Get current block number
                currentBlockNumber = await getCurrentBlockNumber();
                if (!currentBlockNumber) {
                    updateEstimatedResults('block error', 'block error');
                    return false;
                }

                // Query both players data in parallel
                const [attackerResponse, targetResponse] = await Promise.all([
                    fetch(SUBGRAPH_URL, {
                        method: 'POST',
                        headers: { 
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    mode: 'cors',
                        body: JSON.stringify({
                            query: TARGET_PLAYER_QUERY,
                            variables: { playerAddress: connectedWalletAddress.toLowerCase() }
                        })
                    }),
                    fetch(SUBGRAPH_URL, {
                        method: 'POST',
                        headers: { 
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    mode: 'cors',
                        body: JSON.stringify({
                            query: TARGET_PLAYER_QUERY,
                            variables: { playerAddress: targetAddress }
                        })
                    })
                ]);

                const [attackerData_raw, targetData_raw] = await Promise.all([
                    attackerResponse.json(),
                    targetResponse.json()
                ]);

                if (attackerData_raw.errors || targetData_raw.errors) {
                    console.error('GraphQL errors:', attackerData_raw.errors || targetData_raw.errors);
                    updateEstimatedResults('query error', 'query error');
                    return false;
                }

                // Store player data
                attackerData = attackerData_raw.data.player;
                targetData = targetData_raw.data.player;

                if (!attackerData) {
                    updateEstimatedResults('no attacker data', 'no attacker data');
                    return false;
                }

                if (!targetData) {
                    // Target hasn't played yet - create default data
                    targetData = {
                        currentBalance: '0',
                        attackBonus: 0,
                        defenseBonus: 0,
                        activeEffects: []
                    };
                }

                console.log('Both players data loaded successfully');
                return true;

            } catch (error) {
                console.error('Error loading players data:', error);
                updateEstimatedResults('network error', 'network error');
                return false;
            }
        }

        // Function to update estimated results display
        function updateEstimatedResults(damageText, costText) {
            document.getElementById('estimatedDamage').textContent = damageText;
            document.getElementById('estimatedCost').textContent = costText;
        }

        // Function to refresh only attacker data and calculate results
        async function refreshAttackerDataAndCalculate() {
            console.log('refreshAttackerDataAndCalculate called');
            
            if (!connectedWalletAddress) {
                updateEstimatedResults('[connect]', '[connect]');
                return;
            }

            try {
                // Get current block number
                currentBlockNumber = await getCurrentBlockNumber();
                if (!currentBlockNumber) {
                    updateEstimatedResults('block error', 'block error');
                    return;
                }

                // Query attacker data
                const attackerResponse = await fetch(SUBGRAPH_URL, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    mode: 'cors',
                    body: JSON.stringify({
                        query: TARGET_PLAYER_QUERY,
                        variables: { playerAddress: connectedWalletAddress.toLowerCase() }
                    })
                });

                const attackerData_raw = await attackerResponse.json();

                if (attackerData_raw.errors) {
                    console.error('GraphQL errors:', attackerData_raw.errors);
                    updateEstimatedResults('query error', 'query error');
                    return;
                }

                // Store attacker data
                attackerData = attackerData_raw.data.player;

                if (!attackerData) {
                    updateEstimatedResults('no attacker data', 'no attacker data');
                    return;
                }
                
                // Read cheating death status from contract for attacker
                const attackerCheatingDeath = await getPlayerCheatingDeathStatus(connectedWalletAddress);
                attackerData.isCheatingDeath = attackerCheatingDeath;
                
                console.log('Attacker data loaded (including cheating death status):', {
                    address: connectedWalletAddress,
                    isCheatingDeath: attackerCheatingDeath,
                    balance: attackerData.currentBalance
                });

                console.log('Attacker data loaded, calculating...');
                performCalculations();

            } catch (error) {
                console.error('Error loading attacker data:', error);
                updateEstimatedResults('network error', 'network error');
            }
        }

        // Function to perform the actual calculations
        function performCalculations() {
            // Get selected quickhack type
            const selectedQuickhackType = getSelectedQuickhackType();
            
            if (!selectedQuickhackType) {
                updateEstimatedResults('select quickhack', 'select quickhack');
                return;
            }

            try {
                // Calculate damage and cost
                const damage = calculateDamage(selectedQuickhackType);
                const cost = calculateCost(selectedQuickhackType, damage);

                // Check for invalid combinations
                if (damage === -1 || cost === -1) {
                    const targetAddress = document.getElementById('targetAddressInput').value.trim().toLowerCase();
                    const isTargetingSelf = connectedWalletAddress.toLowerCase() === targetAddress;
                    const params = QUICKHACK_PARAMS[selectedQuickhackType];
                    
                    if (isTargetingSelf && !params.selfCastOnly) {
                        // Attack quickhack on self
                        updateEstimatedResults("don't hack yourself", "don't hack yourself");
                    } else if (!isTargetingSelf && params.selfCastOnly) {
                        // Self-cast on enemy
                        updateEstimatedResults("cannot use self-cast on enemy", "cannot use self-cast on enemy");
                    }
                    return;
                }

                // Format and display results
                const formattedDamage = damage > 0 ? `${damage.toLocaleString()} RAM` : '0 RAM';
                const formattedCost = cost > 0 ? `${cost.toLocaleString()} RAM` : '0 RAM';

                console.log('Formatted results:', { formattedDamage, formattedCost });
                updateEstimatedResults(formattedDamage, formattedCost);

                console.log('Full calculation results:', {
                    quickhackType: selectedQuickhackType,
                    damage: damage,
                    cost: cost,
                    attackerBalance: attackerData?.currentBalance,
                    targetBalance: targetData?.currentBalance,
                    currentBlock: currentBlockNumber,
                    connectedWallet: connectedWalletAddress,
                    targetAddress: document.getElementById('targetAddressInput').value.trim()
                });

            } catch (error) {
                console.error('Error in calculations:', error);
                updateEstimatedResults('calc error', 'calc error');
            }
        }

        // Function to calculate damage (mirroring contract logic)
        function calculateDamage(quickhackType) {
            console.log('calculateDamage called with type:', quickhackType);
            
            if (!attackerData || !targetData) {
                console.log('Missing player data:', { attackerData: !!attackerData, targetData: !!targetData });
                return 0;
            }

            const attackerBalance = parseInt(attackerData.currentBalance);
            console.log('Attacker balance:', attackerBalance);
            
            if (attackerBalance === 0) return 0;

            const params = QUICKHACK_PARAMS[quickhackType];
            if (!params) {
                console.log('No params found for quickhack type:', quickhackType);
                return 0;
            }
            
            console.log('Using quickhack params:', params);

            // Check if targeting self
            const targetAddress = document.getElementById('targetAddressInput').value.trim().toLowerCase();
            const isTargetingSelf = connectedWalletAddress.toLowerCase() === targetAddress;
            
            console.log('Targeting check:', {
                connectedWallet: connectedWalletAddress.toLowerCase(),
                targetAddress: targetAddress,
                isTargetingSelf: isTargetingSelf,
                selfCastOnly: params.selfCastOnly
            });
            
            // Self-cast quickhacks have no damage
            if (isTargetingSelf && params.selfCastOnly) {
                console.log('Self-cast quickhack, returning 0 damage');
                return 0;
            }
            
            // Attack quickhacks targeting self are not allowed 
            if (isTargetingSelf && !params.selfCastOnly) {
                console.log('Attack quickhack targeting self, invalid combination');
                return -1; // Special return value to indicate invalid combination
            }

            // Base damage calculation
            let baseDamage = Math.floor(attackerBalance * params.baseDamage / 10000);
            console.log('Base damage calculation:', {
                attackerBalance: attackerBalance,
                baseDamagePercent: params.baseDamage,
                calculatedBaseDamage: baseDamage
            });

            // Special case for TROLL - uses attacker's defense bonus
            if (quickhackType === 4) {
                const attackerDefenseBonus = parseInt(attackerData.defenseBonus || 0);
                const multiplier = 10000 + attackerDefenseBonus;
                baseDamage = Math.floor(baseDamage * multiplier / 10000);
            }

            // Calculate attacker's total attack bonus
            let attackBonus = parseInt(attackerData.attackBonus || 0);
            
            // Add cheating death bonus if applicable (need to read from contract)
            if (attackerData.isCheatingDeath) {
                attackBonus += 3000; // 30% attack bonus
            }

            // Add effect bonuses for attack damage (BERSERK, DOWNSTREAM)
            const attackEffectBonus = calculateEffectBonus(attackerData.activeEffects, 1, currentBlockNumber); // ATTACK_DAMAGE_MOD
            attackBonus += attackEffectBonus;

            // Apply attack bonus
            const bonusMultiplier = 10000 + attackBonus;
            let damageWithBonus = Math.floor(baseDamage * bonusMultiplier / 10000);

            // For boss targets, skip defense calculations
            if (targetData.isBoss) {
                return damageWithBonus;
            }

            // Calculate defender's defense bonus
            let defenseBonus = parseInt(targetData.defenseBonus || 0);
            
            // Add cheating death bonus if applicable
            if (targetData.isCheatingDeath) {
                defenseBonus += 3000; // 30% defense bonus
            }

            // Add effect bonuses/penalties for defense (OVERHEAT, DOWNSTREAM, ICEWALL)
            const defenseEffectBonus = calculateEffectBonus(targetData.activeEffects, 2, currentBlockNumber); // DEFENSE_MOD
            
            // Handle negative defense effects (can't go below 0)
            if (defenseEffectBonus < 0) {
                if (Math.abs(defenseEffectBonus) >= defenseBonus) {
                    defenseBonus = 0;
                } else {
                    defenseBonus += defenseEffectBonus; // Adding negative value
                }
            } else {
                defenseBonus += defenseEffectBonus;
            }

            // Apply defense reduction
            let damageAfterDefense = Math.floor(damageWithBonus * 10000 / (10000 + defenseBonus));
            
            // Apply game state modifier (need to pass gameState from global or parameter)
            if (window.currentGameState) {
                damageAfterDefense = applyGameStateModifier(damageAfterDefense, window.currentGameState);
            }

            // Cap damage if it would leave defender with less than minimum (1 RAM)
            const targetBalance = parseInt(targetData.currentBalance);
            if (targetBalance <= 1) {
                return 0;
            } else if (targetBalance - damageAfterDefense < 1) {
                return targetBalance - 1;
            }

            return damageAfterDefense;
        }

        // Function to calculate cost (mirroring contract logic)
        function calculateCost(quickhackType, damage) {
            console.log('calculateCost called with:', { quickhackType, damage });
            
            if (!attackerData) return 0;

            const attackerBalance = parseInt(attackerData.currentBalance);
            const params = QUICKHACK_PARAMS[quickhackType];
            if (!params) {
                console.log('No params found for cost calculation, quickhack type:', quickhackType);
                return 0;
            }
            
            console.log('Cost calculation params:', params);

            const targetAddress = document.getElementById('targetAddressInput').value.trim().toLowerCase();
            const isTargetingSelf = connectedWalletAddress.toLowerCase() === targetAddress;

            // Check for invalid combinations first
            if (!isTargetingSelf && params.selfCastOnly) {
                console.log('Self-cast quickhack on enemy, invalid combination');
                return -1; // Special return value to indicate invalid combination
            }

            if (isTargetingSelf && !params.selfCastOnly) {
                console.log('Attack quickhack on self, invalid combination');
                return -1; // Special return value to indicate invalid combination
            }

            // For self-cast buffs, use fixed costs based on balance
            if (isTargetingSelf && params.selfCastOnly) {
                const costPercentage = params.fixedCostPercent || 200; // Default 2%
                let fixedCost = Math.floor(attackerBalance * costPercentage / 10000);

                // Apply power scaling to self-cast costs based on attacker's attack bonus
                let attackBonus = parseInt(attackerData.attackBonus || 0);
                
                // Add cheating death bonus if applicable
                if (attackerData.isCheatingDeath) {
                    attackBonus += 3000; // 30% attack bonus
                }
                
                if (attackBonus > 0) {
                    const powerTax = Math.floor(attackBonus / 2); // Attack bonus ÷ 2
                    fixedCost = Math.floor(fixedCost * (10000 + powerTax) / 10000);
                }
                
                // Apply game state modifier
                if (window.currentGameState) {
                    fixedCost = applyGameStateModifier(fixedCost, window.currentGameState);
                }

                return fixedCost;
            }

            // For attacks, derive cost from damage
            const costPercentOfDamage = params.costDamageRatio;
            let baseCost = Math.floor(damage * costPercentOfDamage / 10000);
            
            console.log('Attack cost calculation:', {
                damage: damage,
                costPercentOfDamage: costPercentOfDamage,
                baseCost: baseCost
            });

            // Calculate attacker's total cost modifier from effects (OILBATH, SHORT CIRCUIT)
            const costEffectBonus = calculateEffectBonus(attackerData.activeEffects, 3, currentBlockNumber); // ATTACK_COST_MOD

            // Apply cost modifier
            let costWithModifiers;
            if (costEffectBonus < 0) {
                // Negative modifier (discount like OILBATH)
                const discount = Math.abs(costEffectBonus);
                costWithModifiers = Math.floor(baseCost * (10000 - discount) / 10000);
            } else {
                // Positive modifier (increase like SHORT CIRCUIT)
                costWithModifiers = Math.floor(baseCost * (10000 + costEffectBonus) / 10000);
            }

            // Apply power scaling to attack costs based on attacker's attack bonus
            let attackBonus = parseInt(attackerData.attackBonus || 0);
            
            // Add cheating death bonus if applicable
            if (attackerData.isCheatingDeath) {
                attackBonus += 3000; // 30% attack bonus
            }
            
            if (attackBonus > 0) {
                const powerTax = Math.floor(attackBonus / 2); // Attack bonus ÷ 2
                costWithModifiers = Math.floor(costWithModifiers * (10000 + powerTax) / 10000);
            }
            
            // Apply game state modifier
            if (window.currentGameState) {
                costWithModifiers = applyGameStateModifier(costWithModifiers, window.currentGameState);
            }

            // Cap cost at attacker's balance
            if (costWithModifiers > attackerBalance) {
                costWithModifiers = attackerBalance;
            }

            console.log('Final cost calculation result:', {
                baseCost: baseCost,
                costWithModifiers: costWithModifiers,
                attackBonus: attackBonus,
                finalCost: costWithModifiers
            });

            return costWithModifiers;
        }

        // Function to calculate and display estimated results
        async function calculateEstimatedResults() {
            console.log('calculateEstimatedResults called');
            
            // Check if wallet is connected
            if (!connectedWalletAddress) {
                console.log('No wallet connected');
                updateEstimatedResults('[connect]', '[connect]');
                return;
            }

            // Refresh both players data first
            const success = await refreshBothPlayersData();
            if (!success) {
                console.log('Failed to refresh both players data');
                return; // Error messages already displayed
            }

            // Get selected quickhack type
            const selectedQuickhackType = getSelectedQuickhackType();
            console.log('Selected quickhack type:', selectedQuickhackType);
            
            if (!selectedQuickhackType) {
                updateEstimatedResults('select quickhack', 'select quickhack');
                return;
            }

            try {
                // Calculate damage and cost
                const damage = calculateDamage(selectedQuickhackType);
                const cost = calculateCost(selectedQuickhackType, damage);

                console.log('Raw calculation results:', { damage, cost });

                // Check for invalid combinations
                if (damage === -1 || cost === -1) {
                    const targetAddress = document.getElementById('targetAddressInput').value.trim().toLowerCase();
                    const isTargetingSelf = connectedWalletAddress.toLowerCase() === targetAddress;
                    const params = QUICKHACK_PARAMS[selectedQuickhackType];
                    
                    if (isTargetingSelf && !params.selfCastOnly) {
                        // Attack quickhack on self
                        updateEstimatedResults("don't hack yourself", "don't hack yourself");
                    } else if (!isTargetingSelf && params.selfCastOnly) {
                        // Self-cast on enemy
                        updateEstimatedResults("cannot use self-cast on enemy", "cannot use self-cast on enemy");
                    }
                    return;
                }

                // Format and display results
                const formattedDamage = damage > 0 ? `${damage.toLocaleString()} RAM` : '0 RAM';
                const formattedCost = cost > 0 ? `${cost.toLocaleString()} RAM` : '0 RAM';

                console.log('Formatted results:', { formattedDamage, formattedCost });
                updateEstimatedResults(formattedDamage, formattedCost);

                console.log('Full calculation results:', {
                    quickhackType: selectedQuickhackType,
                    damage: damage,
                    cost: cost,
                    attackerBalance: attackerData?.currentBalance,
                    targetBalance: targetData?.currentBalance,
                    currentBlock: currentBlockNumber,
                    connectedWallet: connectedWalletAddress,
                    targetAddress: document.getElementById('targetAddressInput').value.trim()
                });

            } catch (error) {
                console.error('Error calculating results:', error);
                updateEstimatedResults('calc error', 'calc error');
            }
        }

        // Function to get currently selected quickhack type
        function getSelectedQuickhackType() {
            // Check which quickhack button is selected
            const selectedBtn = document.querySelector('.quickhack-btn.selected');
            console.log('Selected button element:', selectedBtn);
            
            if (!selectedBtn) {
                console.log('No quickhack button selected');
                return null;
            }

            const btnText = selectedBtn.textContent.toLowerCase();
            console.log('Selected button text:', btnText);
            
            // Map button text to quickhack type numbers
            const quickhackMap = {
                'short circuit': 1,
                'overheat': 2,
                'lag': 3,
                'troll': 4,
                'berserk': 5,
                'oilbath': 6,
                'on/off': 7,  // Fixed to match HTML button text
                'downstream': 8,
                'icewall': 9
            };

            const mappedType = quickhackMap[btnText] || null;
            console.log('Mapped quickhack type:', mappedType);
            return mappedType;
        }

        // GraphQL query for recent activities
        const ACTIVITY_QUERY = `
            query GetRecentActivities($lastTimestamp: BigInt) {
                activities(
                    first: 50, 
                    orderBy: blockTimestamp, 
                    orderDirection: desc,
                    where: { blockTimestamp_gt: $lastTimestamp }
                ) {
                    id
                    type
                    player { id }
                    target { id }
                    quickhackType
                    amount
                    cost
                    blockTimestamp
                    transactionHash
                    isAttack
                    isSelfCast
                }
            }
        `;

        // Fetch activities from subgraph
        // GraphQL query for initial activities load (no timestamp filter)
        const INITIAL_ACTIVITY_QUERY = `
            query GetInitialActivities {
                activities(
                    first: 50, 
                    orderBy: blockTimestamp, 
                    orderDirection: desc
                ) {
                    id
                    type
                    player { id }
                    target { id }
                    quickhackType
                    amount
                    cost
                    blockTimestamp
                    transactionHash
                    isAttack
                    isSelfCast
                }
            }
        `;

        async function fetchActivities(fromTimestamp = 0, isInitialLoad = false) {
            try {
                const query = isInitialLoad ? INITIAL_ACTIVITY_QUERY : ACTIVITY_QUERY;
                const variables = isInitialLoad ? {} : { lastTimestamp: fromTimestamp.toString() };
                
                const response = await fetch(SUBGRAPH_URL, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    mode: 'cors',
                    body: JSON.stringify({
                        query: query,
                        variables: variables
                    })
                });
                
                const data = await response.json();
                if (data.errors) {
                    console.error('GraphQL errors:', data.errors);
                    return [];
                }
                
                return data.data.activities || [];
            } catch (error) {
                console.error('Failed to fetch activities:', error);
                return [];
            }
        }

        // Convert blockchain activity to display format
        function formatActivity(activity) {
            const playerShort = activity.player.id.slice(0, 6) + '...' + activity.player.id.slice(-4);
            const targetShort = activity.target ? activity.target.id.slice(0, 6) + '...' + activity.target.id.slice(-4) : null;
            
            // Quickhack type names
            const quickhackNames = {
                1: 'short circuit', 2: 'overheat', 3: 'lag', 4: 'troll',
                5: 'berserk', 6: 'oilbath', 7: 'on/off', 8: 'downstream', 9: 'icewall'
            };
            
            let text, type;
            
            switch (activity.type) {
                case 'DEPOSIT':
                    const ethAmount = (parseFloat(activity.amount) / 1e18).toFixed(3);
                    text = `<span class="clickable-address" data-address="${activity.player.id}">${playerShort}</span> ⬇ ${ethAmount} eth`;
                    type = 'deposit';
                    break;
                    
                case 'WITHDRAWAL':
                    const ramAmount = Math.floor(parseFloat(activity.amount) / 1000);
                    text = `<span class="clickable-address" data-address="${activity.player.id}">${playerShort}</span> ⬆ ${ramAmount}k ram`;
                    type = 'withdraw';
                    break;
                    
                case 'ATTACK':
                    const quickhackName = quickhackNames[activity.quickhackType] || 'unknown';
                    text = `<span class="clickable-address" data-address="${activity.player.id}">${playerShort}</span> ⮕ <span class="clickable-address" data-address="${activity.target.id}">${targetShort}</span> ${quickhackName}`;
                    type = 'attack';
                    break;
                    
                case 'SELF_CAST':
                    const selfQuickhackName = quickhackNames[activity.quickhackType] || 'unknown';
                    text = `<span class="clickable-address" data-address="${activity.player.id}">${playerShort}</span> ⬅ ${selfQuickhackName}`;
                    type = 'self-cast';
                    break;
                    
                default:
                    text = `<span class="clickable-address" data-address="${activity.player.id}">${playerShort}</span> unknown activity`;
                    type = 'deposit';
            }
            
            return { text, type, timestamp: parseInt(activity.blockTimestamp) };
        }

        // Add real activity to feed
        function addRealActivity(activityData) {
            const feed = document.getElementById('activityFeed');
            const feedItem = document.createElement('div');
            feedItem.className = `feed-item ${activityData.type}`;
            feedItem.innerHTML = activityData.text;
            
            // Flash animation
            const flashClass = `flash-${activityData.type === 'withdraw' ? 'deposit' : activityData.type}`;
            feedItem.classList.add(flashClass);
            setTimeout(() => feedItem.classList.remove(flashClass), 500);
            
            feed.insertBefore(feedItem, feed.firstChild);
            
            // Setup click handlers for addresses
            feedItem.querySelectorAll('.clickable-address').forEach(addr => {
                addr.addEventListener('click', function() {
                    const targetInput = document.querySelector('.target-input');
                    if (targetInput) {
                        targetInput.value = this.getAttribute('data-address');
                    }
                });
            });
            
            // Limit feed to 200 items
            while (feed.children.length > 200) {
                feed.removeChild(feed.lastChild);
            }
        }

        // Load recent activities on page load
        async function loadRecentActivities() {
            const activities = await fetchActivities(0, true); // isInitialLoad = true
            activities.reverse().forEach(activity => {
                const formatted = formatActivity(activity);
                addRealActivity(formatted);
                lastActivityTimestamp = Math.max(lastActivityTimestamp, formatted.timestamp);
            });
        }

        // Check for new activities
        async function checkForNewActivities() {
            console.log('Checking for new activities...');
            const newActivities = await fetchActivities(lastActivityTimestamp);
            console.log(`Found ${newActivities.length} new activities`);
            if (newActivities.length > 0) {
                newActivities.reverse().forEach(activity => {
                    const formatted = formatActivity(activity);
                    addRealActivity(formatted);
                    lastActivityTimestamp = Math.max(lastActivityTimestamp, formatted.timestamp);
                });
            }
        }

        // Legacy addActivity function removed - activity is now handled by real GraphQL data

        // Apply dynamic styling to player items based on status
        function updatePlayerStyling() {
            players.forEach((player, index) => {
                const playerElement = document.querySelector(`#player-${index}`);
                if (!playerElement) return; // Skip if element doesn't exist
                const playerItem = playerElement.parentElement;
                const balanceElement = playerItem.querySelector('.player-balance');
                
                // Player status styling removed - clean appearance
                
                // Balance styling removed - using consistent RAM purple color
            });
            
            // Style effects
            document.querySelectorAll('.effect-item').forEach(effect => {
                const text = effect.textContent;
                if (text.includes('berserk') || text.includes('downstream') || text.includes('oilbath')) {
                    effect.classList.add('positive');
                } else if (text.includes('overheat') || text.includes('short circuit') || text.includes('troll')) {
                    effect.classList.add('negative');
                } else if (text.includes('on/off') || text.includes('icewall')) {
                    effect.classList.add('protection');
                }
            });
            
            // Style activity items based on quickhack type
            document.querySelectorAll('.activity-item').forEach(activity => {
                const text = activity.textContent;
                if (text.includes('⮕')) {
                    activity.classList.add('attack');
                } else if (text.includes('⬅') && !text.includes('⬆')) {
                    activity.classList.add('self-cast');
                }
            });
        }

        // Update header status styling
        function updateHeaderStyling() {
            const gameState = document.querySelector('.header-item:nth-child(4) .header-value');
            
            if (gameState.textContent === 'boss mode') {
                gameState.classList.add('boss-mode');
            } else if (gameState.textContent === 'emergency') {
                gameState.classList.add('danger');
            }
            
            // Boss balance and other values use special RAM purple color
        }





        // Placeholder function for PFP set functionality
        function setPFP() {
            alert('PFP set! (Future: will save PFP to player profile)');
        }

        // Loading animation system
        function animateLoadingBarSection(barId, duration = 2000) {
            const loadingBar = document.getElementById(barId);
            const binaryChars = ['0', '1'];
            const barLength = 20;
            let progress = 0;
            
            const interval = setInterval(() => {
                let bar = '';
                for (let i = 0; i < barLength; i++) {
                    if (i < progress) {
                        bar += binaryChars[Math.floor(Math.random() * 2)];
                    } else {
                        bar += '.';
                    }
                }
                loadingBar.textContent = `[${bar}]`;
                
                progress++;
                if (progress > barLength) {
                    clearInterval(interval);
                    loadingBar.textContent = `[${'1'.repeat(barLength)}]`;
                }
            }, duration / barLength);
            
            return new Promise(resolve => {
                setTimeout(resolve, duration + 200);
            });
        }

        function hideLoadingShowContent(loadingId, contentId) {
            document.getElementById(loadingId).style.display = 'none';
            document.getElementById(contentId).classList.add('loaded');
        }

        async function initializeLoadingSequence() {
            // Load sections progressively with delays
            
            // Start all loading animations simultaneously with same duration
            animateLoadingBarSection('playersLoadingBar', 1500);
            animateLoadingBarSection('activityLoadingBar', 1500);
            animateLoadingBarSection('pfpLoadingBar', 1500);
            animateLoadingBarSection('profileLoadingBar', 1500);
            animateLoadingBarSection('simulatorLoadingBar', 1500);
            
            // Show content progressively
            setTimeout(() => {
                hideLoadingShowContent('playersLoading', 'playerList');
                loadAndPopulatePlayerList();
            }, 1600);
            
            setTimeout(() => {
                hideLoadingShowContent('simulatorLoading', 'simulatorSection');
            }, 1700);
            
            setTimeout(() => {
                hideLoadingShowContent('pfpLoading', 'pfpSection');
                // Don't initialize PFP until player connects
            }, 1900);
            
            setTimeout(() => {
                hideLoadingShowContent('activityLoading', 'activityFeed');
                // Load initial activities and start polling
                loadRecentActivities();
                setTimeout(() => loadBossBalance(), 2000); // Stagger by 2 seconds
                setTimeout(() => loadCurrentBlock(), 4000); // Stagger by 4 seconds  
                setTimeout(() => loadGasPrice(), 6000); // Stagger by 6 seconds
                setTimeout(() => refreshGameStateAndCalculations(), 8000); // Load game state
                setInterval(checkForNewActivities, 60000); // Check every 60 seconds
                setInterval(smartUpdatePlayerList, 90000); // Smart update players every 90 seconds
                setInterval(loadBossBalance, 120000); // Update boss balance every 2 minutes
                setInterval(loadCurrentBlock, 60000); // Update block number every minute
                setInterval(loadGasPrice, 180000); // Update gas price every 3 minutes
                setInterval(refreshGameStateAndCalculations, 180000); // Update game state every 3 minutes
            }, 1500);
            
            setTimeout(() => {
                hideLoadingShowContent('profileLoading', 'profileSection');
                setDisconnectedState(); // Initialize in disconnected state
            }, 2300);
        }





        // Initialize the page
        document.addEventListener('DOMContentLoaded', function() {
            updateHeaderStyling();
            
            // Start the loading sequence
            initializeLoadingSequence();
            
            // Initialize map after a delay
            setTimeout(() => {
                animateLoadingBarSection('mapLoadingBar', 1500);
                setTimeout(() => {
                    hideLoadingShowContent('mapLoading', 'mapSection');
                    setTimeout(async () => {
                        // Initialize map (it will fetch its own data)
                        await initializeGameMap();
                    }, 200);
                }, 1600);
            }, 500);
            
            // Apply styling after content loads
            setTimeout(() => {
                updatePlayerStyling();
            }, 3000);
            
            // Add click handlers to existing addresses in the activity feed
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('clickable-address')) {
                    const targetInput = document.querySelector('.target-input');
                    targetInput.value = e.target.getAttribute('data-address');
                }
            });
            
            // Handle window resize to update responsive addresses
            window.addEventListener('resize', function() {
                // Update active players list addresses
                const playerAddresses = document.querySelectorAll('.player-address.clickable-address');
                playerAddresses.forEach(addressElement => {
                    const fullAddress = addressElement.getAttribute('data-address');
                    addressElement.textContent = getResponsiveAddress(fullAddress);
                });
                
                // Update player profile title if connected
                if (connectedWalletAddress) {
                    const profileTitle = document.getElementById('profileTitle');
                    profileTitle.textContent = `PLAYER ${getResponsiveAddress(connectedWalletAddress)}`;
                }
            });
        });
    </script>
</body>
</html>